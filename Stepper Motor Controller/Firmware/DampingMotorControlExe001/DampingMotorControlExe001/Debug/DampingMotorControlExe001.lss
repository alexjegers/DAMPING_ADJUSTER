
DampingMotorControlExe001.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00807000  00000d88  00000e1c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d88  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000021  00807008  00807008  00000e24  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e24  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000e54  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002c8  00000000  00000000  00000e90  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005b6a  00000000  00000000  00001158  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002c44  00000000  00000000  00006cc2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001559  00000000  00000000  00009906  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006a0  00000000  00000000  0000ae60  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002754  00000000  00000000  0000b500  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000c5c  00000000  00000000  0000dc54  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000288  00000000  00000000  0000e8b0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
   4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
   8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
   c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  18:	0c 94 84 02 	jmp	0x508	; 0x508 <__vector_6>
  1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  30:	0c 94 f8 02 	jmp	0x5f0	; 0x5f0 <__vector_12>
  34:	0c 94 21 03 	jmp	0x642	; 0x642 <__vector_13>
  38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  7c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  80:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  84:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  88:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  8c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  90:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  94:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  98:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  9c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  a0:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  a4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  a8:	0c 94 af 02 	jmp	0x55e	; 0x55e <__vector_42>
  ac:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  b0:	a4 01       	movw	r20, r8
  b2:	7e 01       	movw	r14, r28
  b4:	81 01       	movw	r16, r2
  b6:	84 01       	movw	r16, r8
  b8:	87 01       	movw	r16, r14
  ba:	8a 01       	movw	r16, r20
  bc:	8d 01       	movw	r16, r26
  be:	90 01       	movw	r18, r0
  c0:	93 01       	movw	r18, r6

000000c2 <__ctors_end>:
  c2:	11 24       	eor	r1, r1
  c4:	1f be       	out	0x3f, r1	; 63
  c6:	cf ef       	ldi	r28, 0xFF	; 255
  c8:	cd bf       	out	0x3d, r28	; 61
  ca:	df e7       	ldi	r29, 0x7F	; 127
  cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
  ce:	10 e7       	ldi	r17, 0x70	; 112
  d0:	a0 e0       	ldi	r26, 0x00	; 0
  d2:	b0 e7       	ldi	r27, 0x70	; 112
  d4:	e8 e8       	ldi	r30, 0x88	; 136
  d6:	fd e0       	ldi	r31, 0x0D	; 13
  d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
  da:	05 90       	lpm	r0, Z+
  dc:	0d 92       	st	X+, r0
  de:	a8 30       	cpi	r26, 0x08	; 8
  e0:	b1 07       	cpc	r27, r17
  e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
  e4:	20 e7       	ldi	r18, 0x70	; 112
  e6:	a8 e0       	ldi	r26, 0x08	; 8
  e8:	b0 e7       	ldi	r27, 0x70	; 112
  ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
  ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
  ee:	a9 32       	cpi	r26, 0x29	; 41
  f0:	b2 07       	cpc	r27, r18
  f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
  f4:	0e 94 48 03 	call	0x690	; 0x690 <main>
  f8:	0c 94 c2 06 	jmp	0xd84	; 0xd84 <_exit>

000000fc <__bad_interrupt>:
  fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <encoderRotDirection>:
			interrupt.
*/

int8_t encoderRotDirection()
{
	if (ENC_A_LEVEL == ENC_B_LEVEL)
 100:	e0 e0       	ldi	r30, 0x00	; 0
 102:	f4 e0       	ldi	r31, 0x04	; 4
 104:	90 85       	ldd	r25, Z+8	; 0x08
 106:	81 e0       	ldi	r24, 0x01	; 1
 108:	89 27       	eor	r24, r25
 10a:	81 70       	andi	r24, 0x01	; 1
 10c:	90 85       	ldd	r25, Z+8	; 0x08
 10e:	96 95       	lsr	r25
 110:	91 70       	andi	r25, 0x01	; 1
 112:	89 17       	cp	r24, r25
 114:	11 f0       	breq	.+4      	; 0x11a <encoderRotDirection+0x1a>
	{
		return ROTATING_CW;
 116:	8b ef       	ldi	r24, 0xFB	; 251
 118:	08 95       	ret
	}
	else
	{
		return ROTATING_CCW;
 11a:	85 e0       	ldi	r24, 0x05	; 5
	}
 11c:	08 95       	ret

0000011e <iicInit>:
Returns: none
Description: Sets up the TWI hardware.
*/
void iicInit()
{
	pIIC->SCTRLA = (TWI_ENABLE_bm					//Slave enable.
 11e:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 122:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 126:	81 e4       	ldi	r24, 0x41	; 65
 128:	81 87       	std	Z+9, r24	; 0x09
				| TWI_APIEN_bm						//Address or stop interrupt enable.
				| TWI_DIEN_bp)						//Data interrupt enable.
				& ~(TWI_SMEN_bm						//Smart mode OFF.
				| TWI_PMEN_bm);						//Use address match logic.
				
	pIIC->SADDR = DEVICE_ADDR;						//Set the slave address.
 12a:	8a e0       	ldi	r24, 0x0A	; 10
 12c:	84 87       	std	Z+12, r24	; 0x0c
	pIIC->DBGCTRL = 1;								//Run while debuggin.
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	82 83       	std	Z+2, r24	; 0x02
	systemConfigTCB(iicTimeoutTimer, TCB_PER_1SEC);	//Configure the timeout timer to a 1 second timeout.
 132:	6d e8       	ldi	r22, 0x8D	; 141
 134:	7b e5       	ldi	r23, 0x5B	; 91
 136:	80 91 00 70 	lds	r24, 0x7000	; 0x807000 <__DATA_REGION_ORIGIN__>
 13a:	90 91 01 70 	lds	r25, 0x7001	; 0x807001 <__DATA_REGION_ORIGIN__+0x1>
 13e:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <systemConfigTCB>
 142:	08 95       	ret

00000144 <iicAddrOrStopFlag>:
			NONE if neither APIF nor AP are set signifying the interrupt was caused
			by something else. 
*/
int8_t iicAddrOrStopFlag()
{
	if ((pIIC->SSTATUS & TWI_APIF_bm) == 0)
 144:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 148:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 14c:	83 85       	ldd	r24, Z+11	; 0x0b
 14e:	86 ff       	sbrs	r24, 6
 150:	05 c0       	rjmp	.+10     	; 0x15c <iicAddrOrStopFlag+0x18>
	{
		return NONE_FLAG;
	}
	else
	{
		if ((pIIC->SSTATUS & TWI_AP_bm) == 0)
 152:	83 85       	ldd	r24, Z+11	; 0x0b
 154:	80 fd       	sbrc	r24, 0
 156:	04 c0       	rjmp	.+8      	; 0x160 <iicAddrOrStopFlag+0x1c>
		{
			return STOP_FLAG;
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	08 95       	ret
*/
int8_t iicAddrOrStopFlag()
{
	if ((pIIC->SSTATUS & TWI_APIF_bm) == 0)
	{
		return NONE_FLAG;
 15c:	82 e0       	ldi	r24, 0x02	; 2
 15e:	08 95       	ret
	{
		if ((pIIC->SSTATUS & TWI_AP_bm) == 0)
		{
			return STOP_FLAG;
		}
		return ADDRESS_FLAG;
 160:	80 e0       	ldi	r24, 0x00	; 0
	}
}
 162:	08 95       	ret

00000164 <iicSendResponse>:
Description: Writes to TWI.SCTRLB register in response to data and address 
			interrupts. See data sheet for details on what the parameters do.
*/
void iicSendResponse(TWI_SCMD_t response, TWI_ACKACT_t ack)
{
	pIIC->SCTRLB = response | ack;
 164:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 168:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 16c:	86 2b       	or	r24, r22
 16e:	82 87       	std	Z+10, r24	; 0x0a
 170:	08 95       	ret

00000172 <iicReadOrWriteFlag>:
Description: Reads status register to see if the IIC master is requesting to read
			or write.
*/
int8_t iicReadOrWriteFlag()
{
	return pIIC->SSTATUS & TWI_DIR_bm;
 172:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 176:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 17a:	83 85       	ldd	r24, Z+11	; 0x0b
}
 17c:	82 70       	andi	r24, 0x02	; 2
 17e:	08 95       	ret

00000180 <iicDataIntFlag>:
Returns: State of the data interrupt flag.
Description: Returns zero if the flag is not set, non-zero if the flag is set.
*/
int8_t iicDataIntFlag()
{
	return pIIC->SSTATUS & TWI_DIF_bm;
 180:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 184:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 188:	83 85       	ldd	r24, Z+11	; 0x0b
}
 18a:	80 78       	andi	r24, 0x80	; 128
 18c:	08 95       	ret

0000018e <iicReadSdata>:
Returns: Data in TWI slave data (SDATA) register.
Description:
*/
char iicReadSdata()
{
	return pIIC->SDATA;
 18e:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 192:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 196:	85 85       	ldd	r24, Z+13	; 0x0d
}
 198:	08 95       	ret

0000019a <iicSetInternalAddress>:
Returns: none
Description: sets the internalAddress enum.
*/
void iicSetInternalAddress(INTERNAL_ADDRESS_t setInternalAddr)
{
	internalAddress = setInternalAddr;
 19a:	80 93 08 70 	sts	0x7008, r24	; 0x807008 <__data_end>
 19e:	08 95       	ret

000001a0 <iicWaitForDataIntFlag>:
Description: Sits in a while loop until the data interrupt flag is set.
*/

void iicWaitForDataIntFlag()
{
	systemEnableTCB(iicTimeoutTimer);
 1a0:	80 91 00 70 	lds	r24, 0x7000	; 0x807000 <__DATA_REGION_ORIGIN__>
 1a4:	90 91 01 70 	lds	r25, 0x7001	; 0x807001 <__DATA_REGION_ORIGIN__+0x1>
 1a8:	0e 94 6f 06 	call	0xcde	; 0xcde <systemEnableTCB>
	
	/*Wait for data*/
	while (iicDataIntFlag() == 0)
 1ac:	0b c0       	rjmp	.+22     	; 0x1c4 <iicWaitForDataIntFlag+0x24>
	{
		if (iicTimeoutTimer->INTFLAGS != 0)
 1ae:	e0 91 00 70 	lds	r30, 0x7000	; 0x807000 <__DATA_REGION_ORIGIN__>
 1b2:	f0 91 01 70 	lds	r31, 0x7001	; 0x807001 <__DATA_REGION_ORIGIN__+0x1>
 1b6:	86 81       	ldd	r24, Z+6	; 0x06
 1b8:	88 23       	and	r24, r24
 1ba:	21 f0       	breq	.+8      	; 0x1c4 <iicWaitForDataIntFlag+0x24>
		{
			iicSetInternalAddress(BASE_ADDRESS);
 1bc:	80 e0       	ldi	r24, 0x00	; 0
 1be:	0e 94 cd 00 	call	0x19a	; 0x19a <iicSetInternalAddress>
			break;
 1c2:	04 c0       	rjmp	.+8      	; 0x1cc <iicWaitForDataIntFlag+0x2c>
void iicWaitForDataIntFlag()
{
	systemEnableTCB(iicTimeoutTimer);
	
	/*Wait for data*/
	while (iicDataIntFlag() == 0)
 1c4:	0e 94 c0 00 	call	0x180	; 0x180 <iicDataIntFlag>
 1c8:	88 23       	and	r24, r24
 1ca:	89 f3       	breq	.-30     	; 0x1ae <iicWaitForDataIntFlag+0xe>
			iicSetInternalAddress(BASE_ADDRESS);
			break;
		}
	}

	systemDisableTCB(iicTimeoutTimer);
 1cc:	80 91 00 70 	lds	r24, 0x7000	; 0x807000 <__DATA_REGION_ORIGIN__>
 1d0:	90 91 01 70 	lds	r25, 0x7001	; 0x807001 <__DATA_REGION_ORIGIN__+0x1>
 1d4:	0e 94 74 06 	call	0xce8	; 0xce8 <systemDisableTCB>
 1d8:	08 95       	ret

000001da <iicReadInternalAddress>:
Description:
*/
INTERNAL_ADDRESS_t iicReadInternalAddress(void)
{
	return internalAddress;
}
 1da:	80 91 08 70 	lds	r24, 0x7008	; 0x807008 <__data_end>
 1de:	08 95       	ret

000001e0 <iicWriteSdata>:
Description: writes data to the TWI slave data register (SDATA).
*/

void iicWriteSdata(uint8_t data)
{
	pIIC->SDATA = data;
 1e0:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 1e4:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 1e8:	85 87       	std	Z+13, r24	; 0x0d
 1ea:	08 95       	ret

000001ec <iicKill>:
Returns: none
Description: Disables slave mode.
*/
void iicKill()
{
	TWI1.CTRLA &= ~(TWI_ENABLE_bm);
 1ec:	e0 e2       	ldi	r30, 0x20	; 32
 1ee:	f9 e0       	ldi	r31, 0x09	; 9
 1f0:	80 81       	ld	r24, Z
 1f2:	8e 7f       	andi	r24, 0xFE	; 254
 1f4:	80 83       	st	Z, r24
 1f6:	08 95       	ret

000001f8 <iicWrite>:
Returns: none
Description: Used in response to a IIC Master read request. Puts data on the bus and handles
			the acks/nacks and completes the transaction.
*/
void iicWrite(void *dataAddr, uint8_t size)
{
 1f8:	0f 93       	push	r16
 1fa:	1f 93       	push	r17
 1fc:	cf 93       	push	r28
 1fe:	df 93       	push	r29
 200:	fc 01       	movw	r30, r24
 202:	d6 2f       	mov	r29, r22
	uint8_t *data = (uint8_t*)dataAddr;
	
	for (int8_t i = 0; i < size; i++)
 204:	c0 e0       	ldi	r28, 0x00	; 0
 206:	0e c0       	rjmp	.+28     	; 0x224 <__EEPROM_REGION_LENGTH__+0x24>
	{
		iicWriteSdata(*(data++));
 208:	8f 01       	movw	r16, r30
 20a:	0f 5f       	subi	r16, 0xFF	; 255
 20c:	1f 4f       	sbci	r17, 0xFF	; 255
 20e:	80 81       	ld	r24, Z
 210:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <iicWriteSdata>
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
 214:	60 e0       	ldi	r22, 0x00	; 0
 216:	83 e0       	ldi	r24, 0x03	; 3
 218:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
		iicWaitForDataIntFlag();
 21c:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <iicWaitForDataIntFlag>
*/
void iicWrite(void *dataAddr, uint8_t size)
{
	uint8_t *data = (uint8_t*)dataAddr;
	
	for (int8_t i = 0; i < size; i++)
 220:	cf 5f       	subi	r28, 0xFF	; 255
	{
		iicWriteSdata(*(data++));
 222:	f8 01       	movw	r30, r16
*/
void iicWrite(void *dataAddr, uint8_t size)
{
	uint8_t *data = (uint8_t*)dataAddr;
	
	for (int8_t i = 0; i < size; i++)
 224:	8d 2f       	mov	r24, r29
 226:	90 e0       	ldi	r25, 0x00	; 0
 228:	2c 2f       	mov	r18, r28
 22a:	0c 2e       	mov	r0, r28
 22c:	00 0c       	add	r0, r0
 22e:	33 0b       	sbc	r19, r19
 230:	28 17       	cp	r18, r24
 232:	39 07       	cpc	r19, r25
 234:	4c f3       	brlt	.-46     	; 0x208 <__EEPROM_REGION_LENGTH__+0x8>
		iicWriteSdata(*(data++));
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
		iicWaitForDataIntFlag();
	}
	
	iicSendResponse(TWI_SCMD_COMPTRANS_gc, TWI_ACKACT_ACK_gc);
 236:	60 e0       	ldi	r22, 0x00	; 0
 238:	82 e0       	ldi	r24, 0x02	; 2
 23a:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
}
 23e:	df 91       	pop	r29
 240:	cf 91       	pop	r28
 242:	1f 91       	pop	r17
 244:	0f 91       	pop	r16
 246:	08 95       	ret

00000248 <iicRead>:
Returns: uint64_t
Description: Used in response to an IIC Master write request. Reads in up to
			4 bytes of data and returns them as one whole 64 bit unsigned int.
*/
uint64_t iicRead(uint8_t size)
{
 248:	cf 92       	push	r12
 24a:	df 92       	push	r13
 24c:	ef 92       	push	r14
 24e:	ff 92       	push	r15
 250:	0f 93       	push	r16
 252:	1f 93       	push	r17
 254:	cf 93       	push	r28
 256:	df 93       	push	r29
 258:	cd b7       	in	r28, 0x3d	; 61
 25a:	de b7       	in	r29, 0x3e	; 62
 25c:	28 97       	sbiw	r28, 0x08	; 8
 25e:	cd bf       	out	0x3d, r28	; 61
 260:	de bf       	out	0x3e, r29	; 62
 262:	e8 2e       	mov	r14, r24
	uint64_t incomingData = 0;
 264:	19 82       	std	Y+1, r1	; 0x01
 266:	1a 82       	std	Y+2, r1	; 0x02
 268:	1b 82       	std	Y+3, r1	; 0x03
 26a:	1c 82       	std	Y+4, r1	; 0x04
 26c:	1d 82       	std	Y+5, r1	; 0x05
 26e:	1e 82       	std	Y+6, r1	; 0x06
 270:	1f 82       	std	Y+7, r1	; 0x07
 272:	18 86       	std	Y+8, r1	; 0x08
	uint8_t *pIncomingData = &incomingData;
	
	for (uint8_t i = 0; i < size - 1; i++)
 274:	f1 2c       	mov	r15, r1
			4 bytes of data and returns them as one whole 64 bit unsigned int.
*/
uint64_t iicRead(uint8_t size)
{
	uint64_t incomingData = 0;
	uint8_t *pIncomingData = &incomingData;
 276:	8e 01       	movw	r16, r28
 278:	0f 5f       	subi	r16, 0xFF	; 255
 27a:	1f 4f       	sbci	r17, 0xFF	; 255
	
	for (uint8_t i = 0; i < size - 1; i++)
 27c:	10 c0       	rjmp	.+32     	; 0x29e <iicRead+0x56>
	{
		*(pIncomingData++) = (uint8_t)iicReadSdata();
 27e:	68 01       	movw	r12, r16
 280:	8f ef       	ldi	r24, 0xFF	; 255
 282:	c8 1a       	sub	r12, r24
 284:	d8 0a       	sbc	r13, r24
 286:	0e 94 c7 00 	call	0x18e	; 0x18e <iicReadSdata>
 28a:	f8 01       	movw	r30, r16
 28c:	80 83       	st	Z, r24
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
 28e:	60 e0       	ldi	r22, 0x00	; 0
 290:	83 e0       	ldi	r24, 0x03	; 3
 292:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
		iicWaitForDataIntFlag();		
 296:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <iicWaitForDataIntFlag>
uint64_t iicRead(uint8_t size)
{
	uint64_t incomingData = 0;
	uint8_t *pIncomingData = &incomingData;
	
	for (uint8_t i = 0; i < size - 1; i++)
 29a:	f3 94       	inc	r15
	{
		*(pIncomingData++) = (uint8_t)iicReadSdata();
 29c:	86 01       	movw	r16, r12
uint64_t iicRead(uint8_t size)
{
	uint64_t incomingData = 0;
	uint8_t *pIncomingData = &incomingData;
	
	for (uint8_t i = 0; i < size - 1; i++)
 29e:	2f 2d       	mov	r18, r15
 2a0:	30 e0       	ldi	r19, 0x00	; 0
 2a2:	8e 2d       	mov	r24, r14
 2a4:	90 e0       	ldi	r25, 0x00	; 0
 2a6:	01 97       	sbiw	r24, 0x01	; 1
 2a8:	28 17       	cp	r18, r24
 2aa:	39 07       	cpc	r19, r25
 2ac:	44 f3       	brlt	.-48     	; 0x27e <iicRead+0x36>
	{
		*(pIncomingData++) = (uint8_t)iicReadSdata();
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
		iicWaitForDataIntFlag();		
	}
		*(pIncomingData++) = (uint8_t)iicReadSdata();
 2ae:	0e 94 c7 00 	call	0x18e	; 0x18e <iicReadSdata>
 2b2:	f8 01       	movw	r30, r16
 2b4:	80 83       	st	Z, r24
		iicSendResponse(TWI_SCMD_COMPTRANS_gc, TWI_ACKACT_NACK_gc);
 2b6:	64 e0       	ldi	r22, 0x04	; 4
 2b8:	82 e0       	ldi	r24, 0x02	; 2
 2ba:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
		iicWaitForDataIntFlag();	
 2be:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <iicWaitForDataIntFlag>
	return incomingData;
 2c2:	29 81       	ldd	r18, Y+1	; 0x01
 2c4:	3a 81       	ldd	r19, Y+2	; 0x02
 2c6:	4b 81       	ldd	r20, Y+3	; 0x03
 2c8:	5c 81       	ldd	r21, Y+4	; 0x04
 2ca:	6d 81       	ldd	r22, Y+5	; 0x05
 2cc:	7e 81       	ldd	r23, Y+6	; 0x06
 2ce:	8f 81       	ldd	r24, Y+7	; 0x07
 2d0:	98 85       	ldd	r25, Y+8	; 0x08
 2d2:	28 96       	adiw	r28, 0x08	; 8
 2d4:	cd bf       	out	0x3d, r28	; 61
 2d6:	de bf       	out	0x3e, r29	; 62
 2d8:	df 91       	pop	r29
 2da:	cf 91       	pop	r28
 2dc:	1f 91       	pop	r17
 2de:	0f 91       	pop	r16
 2e0:	ff 90       	pop	r15
 2e2:	ef 90       	pop	r14
 2e4:	df 90       	pop	r13
 2e6:	cf 90       	pop	r12
 2e8:	08 95       	ret

000002ea <iicHandleData>:
Description: Sends or receives requested data determined by internal address and
			iicReadOrWrite.
*/
void iicHandleData(INTERNAL_ADDRESS_t internalAddress)
{
	switch (internalAddress)
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	89 30       	cpi	r24, 0x09	; 9
 2ee:	91 05       	cpc	r25, r1
 2f0:	28 f5       	brcc	.+74     	; 0x33c <iicHandleData+0x52>
 2f2:	fc 01       	movw	r30, r24
 2f4:	e8 5a       	subi	r30, 0xA8	; 168
 2f6:	ff 4f       	sbci	r31, 0xFF	; 255
 2f8:	0c 94 a1 06 	jmp	0xd42	; 0xd42 <__tablejump2__>
	{
		case BASE_ADDRESS:
		break;
		
		case MOTOR_SET_POINT:
			handlerMotorSetPoint();			
 2fc:	0e 94 a8 01 	call	0x350	; 0x350 <handlerMotorSetPoint>
		break;
 300:	23 c0       	rjmp	.+70     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_POSITION:
			handlerMotorPosition();
 302:	0e 94 cb 01 	call	0x396	; 0x396 <handlerMotorPosition>
		break;
 306:	20 c0       	rjmp	.+64     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_SPEED:
			handlerMotorSpeed();
 308:	0e 94 ee 01 	call	0x3dc	; 0x3dc <handlerMotorSpeed>
		break;
 30c:	1d c0       	rjmp	.+58     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_CURRENT:
			handlerMotorCurrent();
 30e:	0e 94 11 02 	call	0x422	; 0x422 <handlerMotorCurrent>
		break;
 312:	1a c0       	rjmp	.+52     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_STEP_MODE:
			handlerMotorStepMode();
 314:	0e 94 32 02 	call	0x464	; 0x464 <handlerMotorStepMode>
		break;
 318:	17 c0       	rjmp	.+46     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_STATUS_FLAGS:
			handlerMotorStatusFlags();
 31a:	0e 94 4f 02 	call	0x49e	; 0x49e <handlerMotorStatusFlags>
		break;
 31e:	14 c0       	rjmp	.+40     	; 0x348 <iicHandleData+0x5e>
		
		case BATTERY_VOLTAGE:
			handlerBatteryVoltage();
 320:	0e 94 68 02 	call	0x4d0	; 0x4d0 <handlerBatteryVoltage>
		break;
 324:	11 c0       	rjmp	.+34     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_GO_TO_ZERO:
			if (iicRead(1) == 0)
 326:	81 e0       	ldi	r24, 0x01	; 1
 328:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 32c:	a0 e0       	ldi	r26, 0x00	; 0
 32e:	0e 94 b6 06 	call	0xd6c	; 0xd6c <__cmpdi2_s8>
 332:	51 f4       	brne	.+20     	; 0x348 <iicHandleData+0x5e>
			{
				stepperSetFlag(FLAG_GO_TO_ZERO_bm);
 334:	88 e0       	ldi	r24, 0x08	; 8
 336:	0e 94 92 05 	call	0xb24	; 0xb24 <stepperSetFlag>
 33a:	06 c0       	rjmp	.+12     	; 0x348 <iicHandleData+0x5e>
			}
		break;
		
		default:
			iicRead(1);										//Process the data in the register to keep the bus from hanging but don't do anything with it.
 33c:	81 e0       	ldi	r24, 0x01	; 1
 33e:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
			iicSetInternalAddress(BASE_ADDRESS);			//Reset to base address.
 342:	80 e0       	ldi	r24, 0x00	; 0
 344:	0e 94 cd 00 	call	0x19a	; 0x19a <iicSetInternalAddress>
		break;
	}		
	iicSetInternalAddress(BASE_ADDRESS);					//Reset to base address after handling data.
 348:	80 e0       	ldi	r24, 0x00	; 0
 34a:	0e 94 cd 00 	call	0x19a	; 0x19a <iicSetInternalAddress>
 34e:	08 95       	ret

00000350 <handlerMotorSetPoint>:

/*For detailed descriptions of the data and access of each address see 
"IIC Procedure" document in "DAMPING_ADJUSTER > Docs" folder.*/

void handlerMotorSetPoint()
{
 350:	cf 93       	push	r28
 352:	df 93       	push	r29
 354:	00 d0       	rcall	.+0      	; 0x356 <handlerMotorSetPoint+0x6>
 356:	cd b7       	in	r28, 0x3d	; 61
 358:	de b7       	in	r29, 0x3e	; 62
	uint16_t setPoint = 0;
 35a:	19 82       	std	Y+1, r1	; 0x01
 35c:	1a 82       	std	Y+2, r1	; 0x02
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 35e:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 362:	81 11       	cpse	r24, r1
 364:	0a c0       	rjmp	.+20     	; 0x37a <handlerMotorSetPoint+0x2a>
	{
		setPoint = iicRead(sizeof(setPoint));
 366:	82 e0       	ldi	r24, 0x02	; 2
 368:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 36c:	82 2f       	mov	r24, r18
 36e:	93 2f       	mov	r25, r19
 370:	29 83       	std	Y+1, r18	; 0x01
 372:	3a 83       	std	Y+2, r19	; 0x02
		stepperSetSetPoint(setPoint);
 374:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <stepperSetSetPoint>
 378:	09 c0       	rjmp	.+18     	; 0x38c <handlerMotorSetPoint+0x3c>
	}
	else
	{
		setPoint = stepperSetPoint();
 37a:	0e 94 32 05 	call	0xa64	; 0xa64 <stepperSetPoint>
 37e:	89 83       	std	Y+1, r24	; 0x01
 380:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&setPoint, sizeof(setPoint));
 382:	62 e0       	ldi	r22, 0x02	; 2
 384:	ce 01       	movw	r24, r28
 386:	01 96       	adiw	r24, 0x01	; 1
 388:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 38c:	0f 90       	pop	r0
 38e:	0f 90       	pop	r0
 390:	df 91       	pop	r29
 392:	cf 91       	pop	r28
 394:	08 95       	ret

00000396 <handlerMotorPosition>:


void handlerMotorPosition()
{
 396:	cf 93       	push	r28
 398:	df 93       	push	r29
 39a:	00 d0       	rcall	.+0      	; 0x39c <handlerMotorPosition+0x6>
 39c:	cd b7       	in	r28, 0x3d	; 61
 39e:	de b7       	in	r29, 0x3e	; 62
	uint16_t position = 0;
 3a0:	19 82       	std	Y+1, r1	; 0x01
 3a2:	1a 82       	std	Y+2, r1	; 0x02
	
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 3a4:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 3a8:	81 11       	cpse	r24, r1
 3aa:	0a c0       	rjmp	.+20     	; 0x3c0 <handlerMotorPosition+0x2a>
	{
		position = iicRead(sizeof(position));
 3ac:	82 e0       	ldi	r24, 0x02	; 2
 3ae:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 3b2:	82 2f       	mov	r24, r18
 3b4:	93 2f       	mov	r25, r19
 3b6:	29 83       	std	Y+1, r18	; 0x01
 3b8:	3a 83       	std	Y+2, r19	; 0x02
		stepperSetPosition(position);
 3ba:	0e 94 fe 04 	call	0x9fc	; 0x9fc <stepperSetPosition>
 3be:	09 c0       	rjmp	.+18     	; 0x3d2 <handlerMotorPosition+0x3c>
	}
	else
	{
		position = stepperPosition();
 3c0:	0e 94 2b 05 	call	0xa56	; 0xa56 <stepperPosition>
 3c4:	89 83       	std	Y+1, r24	; 0x01
 3c6:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&position, sizeof(position));
 3c8:	62 e0       	ldi	r22, 0x02	; 2
 3ca:	ce 01       	movw	r24, r28
 3cc:	01 96       	adiw	r24, 0x01	; 1
 3ce:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 3d2:	0f 90       	pop	r0
 3d4:	0f 90       	pop	r0
 3d6:	df 91       	pop	r29
 3d8:	cf 91       	pop	r28
 3da:	08 95       	ret

000003dc <handlerMotorSpeed>:


void handlerMotorSpeed()
{
 3dc:	cf 93       	push	r28
 3de:	df 93       	push	r29
 3e0:	00 d0       	rcall	.+0      	; 0x3e2 <handlerMotorSpeed+0x6>
 3e2:	cd b7       	in	r28, 0x3d	; 61
 3e4:	de b7       	in	r29, 0x3e	; 62
	uint16_t speed = 0;
 3e6:	19 82       	std	Y+1, r1	; 0x01
 3e8:	1a 82       	std	Y+2, r1	; 0x02
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 3ea:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 3ee:	81 11       	cpse	r24, r1
 3f0:	0a c0       	rjmp	.+20     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
	{
		speed = iicRead(sizeof(speed));
 3f2:	82 e0       	ldi	r24, 0x02	; 2
 3f4:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 3f8:	82 2f       	mov	r24, r18
 3fa:	93 2f       	mov	r25, r19
 3fc:	29 83       	std	Y+1, r18	; 0x01
 3fe:	3a 83       	std	Y+2, r19	; 0x02
		stepperSetSpeed(speed);
 400:	0e 94 61 04 	call	0x8c2	; 0x8c2 <stepperSetSpeed>
 404:	09 c0       	rjmp	.+18     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
	}
	else
	{
		speed = stepperSpeed();
 406:	0e 94 39 05 	call	0xa72	; 0xa72 <stepperSpeed>
 40a:	89 83       	std	Y+1, r24	; 0x01
 40c:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&speed, sizeof(speed));
 40e:	62 e0       	ldi	r22, 0x02	; 2
 410:	ce 01       	movw	r24, r28
 412:	01 96       	adiw	r24, 0x01	; 1
 414:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}		
}
 418:	0f 90       	pop	r0
 41a:	0f 90       	pop	r0
 41c:	df 91       	pop	r29
 41e:	cf 91       	pop	r28
 420:	08 95       	ret

00000422 <handlerMotorCurrent>:


void handlerMotorCurrent()
{
 422:	cf 93       	push	r28
 424:	df 93       	push	r29
 426:	00 d0       	rcall	.+0      	; 0x428 <handlerMotorCurrent+0x6>
 428:	cd b7       	in	r28, 0x3d	; 61
 42a:	de b7       	in	r29, 0x3e	; 62
	CURRENT_LIMIT_t current;
	
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 42c:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 430:	81 11       	cpse	r24, r1
 432:	0a c0       	rjmp	.+20     	; 0x448 <handlerMotorCurrent+0x26>
	{
		current = iicRead(sizeof(current));
 434:	82 e0       	ldi	r24, 0x02	; 2
 436:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 43a:	82 2f       	mov	r24, r18
 43c:	93 2f       	mov	r25, r19
 43e:	29 83       	std	Y+1, r18	; 0x01
 440:	3a 83       	std	Y+2, r19	; 0x02
		stepperSetCurrent(current);
 442:	0e 94 b0 04 	call	0x960	; 0x960 <stepperSetCurrent>
 446:	09 c0       	rjmp	.+18     	; 0x45a <handlerMotorCurrent+0x38>
	}
	else
	{
		current = stepperCurrentLimit();
 448:	0e 94 df 05 	call	0xbbe	; 0xbbe <stepperCurrentLimit>
 44c:	89 83       	std	Y+1, r24	; 0x01
 44e:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&current, sizeof(current));
 450:	62 e0       	ldi	r22, 0x02	; 2
 452:	ce 01       	movw	r24, r28
 454:	01 96       	adiw	r24, 0x01	; 1
 456:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 45a:	0f 90       	pop	r0
 45c:	0f 90       	pop	r0
 45e:	df 91       	pop	r29
 460:	cf 91       	pop	r28
 462:	08 95       	ret

00000464 <handlerMotorStepMode>:


void handlerMotorStepMode()
{
 464:	cf 93       	push	r28
 466:	df 93       	push	r29
 468:	1f 92       	push	r1
 46a:	cd b7       	in	r28, 0x3d	; 61
 46c:	de b7       	in	r29, 0x3e	; 62
	STEP_MODE_t stepMode;
	
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 46e:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 472:	81 11       	cpse	r24, r1
 474:	08 c0       	rjmp	.+16     	; 0x486 <handlerMotorStepMode+0x22>
	{
		stepMode = iicRead(sizeof(stepMode));
 476:	81 e0       	ldi	r24, 0x01	; 1
 478:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 47c:	82 2f       	mov	r24, r18
 47e:	29 83       	std	Y+1, r18	; 0x01
		stepperSetStepMode(stepMode);
 480:	0e 94 4f 04 	call	0x89e	; 0x89e <stepperSetStepMode>
 484:	08 c0       	rjmp	.+16     	; 0x496 <handlerMotorStepMode+0x32>
	}
	else
	{
		stepMode = stepperStepMode();
 486:	0e 94 e6 05 	call	0xbcc	; 0xbcc <stepperStepMode>
 48a:	89 83       	std	Y+1, r24	; 0x01
		iicWrite(&stepMode, sizeof(stepMode));
 48c:	61 e0       	ldi	r22, 0x01	; 1
 48e:	ce 01       	movw	r24, r28
 490:	01 96       	adiw	r24, 0x01	; 1
 492:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 496:	0f 90       	pop	r0
 498:	df 91       	pop	r29
 49a:	cf 91       	pop	r28
 49c:	08 95       	ret

0000049e <handlerMotorStatusFlags>:


void handlerMotorStatusFlags()
{
 49e:	cf 93       	push	r28
 4a0:	df 93       	push	r29
 4a2:	1f 92       	push	r1
 4a4:	cd b7       	in	r28, 0x3d	; 61
 4a6:	de b7       	in	r29, 0x3e	; 62
	uint8_t flags = 0;
 4a8:	19 82       	std	Y+1, r1	; 0x01
	
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 4aa:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 4ae:	81 11       	cpse	r24, r1
 4b0:	03 c0       	rjmp	.+6      	; 0x4b8 <handlerMotorStatusFlags+0x1a>
	{
		iicRead(0);									//Immediately NACK the data, this is a read only address.
 4b2:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 4b6:	08 c0       	rjmp	.+16     	; 0x4c8 <handlerMotorStatusFlags+0x2a>
	}
	else
	{
		flags = stepperFlags();
 4b8:	0e 94 a3 05 	call	0xb46	; 0xb46 <stepperFlags>
 4bc:	89 83       	std	Y+1, r24	; 0x01
		iicWrite(&flags, sizeof(flags));
 4be:	61 e0       	ldi	r22, 0x01	; 1
 4c0:	ce 01       	movw	r24, r28
 4c2:	01 96       	adiw	r24, 0x01	; 1
 4c4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 4c8:	0f 90       	pop	r0
 4ca:	df 91       	pop	r29
 4cc:	cf 91       	pop	r28
 4ce:	08 95       	ret

000004d0 <handlerBatteryVoltage>:


void handlerBatteryVoltage()
{
 4d0:	cf 93       	push	r28
 4d2:	df 93       	push	r29
 4d4:	00 d0       	rcall	.+0      	; 0x4d6 <handlerBatteryVoltage+0x6>
 4d6:	cd b7       	in	r28, 0x3d	; 61
 4d8:	de b7       	in	r29, 0x3e	; 62
	uint16_t voltage = 0;
 4da:	19 82       	std	Y+1, r1	; 0x01
 4dc:	1a 82       	std	Y+2, r1	; 0x02
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 4de:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 4e2:	81 11       	cpse	r24, r1
 4e4:	03 c0       	rjmp	.+6      	; 0x4ec <handlerBatteryVoltage+0x1c>
	{
		iicRead(0);									//Immediately NACK the data, this is a read only address.
 4e6:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 4ea:	09 c0       	rjmp	.+18     	; 0x4fe <handlerBatteryVoltage+0x2e>
	}
	else
	{
		voltage = systemADCResult();
 4ec:	0e 94 56 06 	call	0xcac	; 0xcac <systemADCResult>
 4f0:	89 83       	std	Y+1, r24	; 0x01
 4f2:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&voltage, sizeof(voltage));
 4f4:	62 e0       	ldi	r22, 0x02	; 2
 4f6:	ce 01       	movw	r24, r28
 4f8:	01 96       	adiw	r24, 0x01	; 1
 4fa:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
 4fe:	0f 90       	pop	r0
 500:	0f 90       	pop	r0
 502:	df 91       	pop	r29
 504:	cf 91       	pop	r28
 506:	08 95       	ret

00000508 <__vector_6>:
#include "system.h"
#include "iic.h"

/*Port A interrupt for encoder*/
ISR(PORTA_PORT_vect)
{
 508:	1f 92       	push	r1
 50a:	0f 92       	push	r0
 50c:	0f b6       	in	r0, 0x3f	; 63
 50e:	0f 92       	push	r0
 510:	11 24       	eor	r1, r1
 512:	2f 93       	push	r18
 514:	3f 93       	push	r19
 516:	4f 93       	push	r20
 518:	5f 93       	push	r21
 51a:	6f 93       	push	r22
 51c:	7f 93       	push	r23
 51e:	8f 93       	push	r24
 520:	9f 93       	push	r25
 522:	af 93       	push	r26
 524:	bf 93       	push	r27
 526:	ef 93       	push	r30
 528:	ff 93       	push	r31
	stepperClearTimeoutTimer();									//Reset the timeout counter because it just moved a step.
 52a:	0e 94 77 05 	call	0xaee	; 0xaee <stepperClearTimeoutTimer>
	int8_t direction = encoderRotDirection();					//Determine direction motor is rotating.
 52e:	0e 94 80 00 	call	0x100	; 0x100 <encoderRotDirection>
	stepperIncrementPosition(direction);						//Add/subtract from the current position.
 532:	0e 94 6e 04 	call	0x8dc	; 0x8dc <stepperIncrementPosition>
	PORTA.INTFLAGS = ENC_A_PIN;									//Clear interrupt flag.
 536:	81 e0       	ldi	r24, 0x01	; 1
 538:	80 93 09 04 	sts	0x0409, r24	; 0x800409 <__RODATA_PM_OFFSET__+0x7f8409>
}
 53c:	ff 91       	pop	r31
 53e:	ef 91       	pop	r30
 540:	bf 91       	pop	r27
 542:	af 91       	pop	r26
 544:	9f 91       	pop	r25
 546:	8f 91       	pop	r24
 548:	7f 91       	pop	r23
 54a:	6f 91       	pop	r22
 54c:	5f 91       	pop	r21
 54e:	4f 91       	pop	r20
 550:	3f 91       	pop	r19
 552:	2f 91       	pop	r18
 554:	0f 90       	pop	r0
 556:	0f be       	out	0x3f, r0	; 63
 558:	0f 90       	pop	r0
 55a:	1f 90       	pop	r1
 55c:	18 95       	reti

0000055e <__vector_42>:

/*IIC interrupt for incoming data*/
ISR(TWI1_TWIS_vect)
{
 55e:	1f 92       	push	r1
 560:	0f 92       	push	r0
 562:	0f b6       	in	r0, 0x3f	; 63
 564:	0f 92       	push	r0
 566:	11 24       	eor	r1, r1
 568:	2f 93       	push	r18
 56a:	3f 93       	push	r19
 56c:	4f 93       	push	r20
 56e:	5f 93       	push	r21
 570:	6f 93       	push	r22
 572:	7f 93       	push	r23
 574:	8f 93       	push	r24
 576:	9f 93       	push	r25
 578:	af 93       	push	r26
 57a:	bf 93       	push	r27
 57c:	ef 93       	push	r30
 57e:	ff 93       	push	r31
	if (iicReadInternalAddress() == BASE_ADDRESS)								//If it's starting for the first time.
 580:	0e 94 ed 00 	call	0x1da	; 0x1da <iicReadInternalAddress>
 584:	81 11       	cpse	r24, r1
 586:	17 c0       	rjmp	.+46     	; 0x5b6 <__vector_42+0x58>
	{
		if (iicAddrOrStopFlag() == ADDRESS_FLAG)											//And it's not a stop.
 588:	0e 94 a2 00 	call	0x144	; 0x144 <iicAddrOrStopFlag>
 58c:	81 11       	cpse	r24, r1
 58e:	1f c0       	rjmp	.+62     	; 0x5ce <__vector_42+0x70>
		{
			if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)						//And it's requesting to write means it going to be an internal address.
 590:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 594:	81 11       	cpse	r24, r1
 596:	1b c0       	rjmp	.+54     	; 0x5ce <__vector_42+0x70>
			{
				iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);		//Acknowledge
 598:	60 e0       	ldi	r22, 0x00	; 0
 59a:	83 e0       	ldi	r24, 0x03	; 3
 59c:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
				iicWaitForDataIntFlag();
 5a0:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <iicWaitForDataIntFlag>
				iicSetInternalAddress((INTERNAL_ADDRESS_t)iicReadSdata());		//Save the internal address.
 5a4:	0e 94 c7 00 	call	0x18e	; 0x18e <iicReadSdata>
 5a8:	0e 94 cd 00 	call	0x19a	; 0x19a <iicSetInternalAddress>
				iicSendResponse(TWI_SCMD_COMPTRANS_gc, TWI_ACKACT_NACK_gc);		//Acknowledge
 5ac:	64 e0       	ldi	r22, 0x04	; 4
 5ae:	82 e0       	ldi	r24, 0x02	; 2
 5b0:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
 5b4:	0c c0       	rjmp	.+24     	; 0x5ce <__vector_42+0x70>
			}
		}
	}
	else //Not the BASE_ADDRESS means the internal address is already written.
	{
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
 5b6:	60 e0       	ldi	r22, 0x00	; 0
 5b8:	83 e0       	ldi	r24, 0x03	; 3
 5ba:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
		while (iicDataIntFlag() == 0) {}		
 5be:	0e 94 c0 00 	call	0x180	; 0x180 <iicDataIntFlag>
 5c2:	88 23       	and	r24, r24
 5c4:	e1 f3       	breq	.-8      	; 0x5be <__vector_42+0x60>
		iicHandleData(iicReadInternalAddress());
 5c6:	0e 94 ed 00 	call	0x1da	; 0x1da <iicReadInternalAddress>
 5ca:	0e 94 75 01 	call	0x2ea	; 0x2ea <iicHandleData>
	}
	
}
 5ce:	ff 91       	pop	r31
 5d0:	ef 91       	pop	r30
 5d2:	bf 91       	pop	r27
 5d4:	af 91       	pop	r26
 5d6:	9f 91       	pop	r25
 5d8:	8f 91       	pop	r24
 5da:	7f 91       	pop	r23
 5dc:	6f 91       	pop	r22
 5de:	5f 91       	pop	r21
 5e0:	4f 91       	pop	r20
 5e2:	3f 91       	pop	r19
 5e4:	2f 91       	pop	r18
 5e6:	0f 90       	pop	r0
 5e8:	0f be       	out	0x3f, r0	; 63
 5ea:	0f 90       	pop	r0
 5ec:	1f 90       	pop	r1
 5ee:	18 95       	reti

000005f0 <__vector_12>:


/*IIC timeout interrupt.*/
ISR(TCB0_INT_vect)
{
 5f0:	1f 92       	push	r1
 5f2:	0f 92       	push	r0
 5f4:	0f b6       	in	r0, 0x3f	; 63
 5f6:	0f 92       	push	r0
 5f8:	11 24       	eor	r1, r1
 5fa:	2f 93       	push	r18
 5fc:	3f 93       	push	r19
 5fe:	4f 93       	push	r20
 600:	5f 93       	push	r21
 602:	6f 93       	push	r22
 604:	7f 93       	push	r23
 606:	8f 93       	push	r24
 608:	9f 93       	push	r25
 60a:	af 93       	push	r26
 60c:	bf 93       	push	r27
 60e:	ef 93       	push	r30
 610:	ff 93       	push	r31
	iicKill();							//Disable IIC slave.
 612:	0e 94 f6 00 	call	0x1ec	; 0x1ec <iicKill>
	iicInit();							//Enable IIC slave.
 616:	0e 94 8f 00 	call	0x11e	; 0x11e <iicInit>
	TCB0.INTFLAGS = TCB_CAPT_bm;		//Clear interrupt flag.
 61a:	81 e0       	ldi	r24, 0x01	; 1
 61c:	80 93 06 0b 	sts	0x0B06, r24	; 0x800b06 <__RODATA_PM_OFFSET__+0x7f8b06>
}
 620:	ff 91       	pop	r31
 622:	ef 91       	pop	r30
 624:	bf 91       	pop	r27
 626:	af 91       	pop	r26
 628:	9f 91       	pop	r25
 62a:	8f 91       	pop	r24
 62c:	7f 91       	pop	r23
 62e:	6f 91       	pop	r22
 630:	5f 91       	pop	r21
 632:	4f 91       	pop	r20
 634:	3f 91       	pop	r19
 636:	2f 91       	pop	r18
 638:	0f 90       	pop	r0
 63a:	0f be       	out	0x3f, r0	; 63
 63c:	0f 90       	pop	r0
 63e:	1f 90       	pop	r1
 640:	18 95       	reti

00000642 <__vector_13>:

/*Stepper timeout interrupt.*/
ISR(TCB1_INT_vect)
{
 642:	1f 92       	push	r1
 644:	0f 92       	push	r0
 646:	0f b6       	in	r0, 0x3f	; 63
 648:	0f 92       	push	r0
 64a:	11 24       	eor	r1, r1
 64c:	2f 93       	push	r18
 64e:	3f 93       	push	r19
 650:	4f 93       	push	r20
 652:	5f 93       	push	r21
 654:	6f 93       	push	r22
 656:	7f 93       	push	r23
 658:	8f 93       	push	r24
 65a:	9f 93       	push	r25
 65c:	af 93       	push	r26
 65e:	bf 93       	push	r27
 660:	ef 93       	push	r30
 662:	ff 93       	push	r31
	stepperIncrementTimeoutCount();		//Increment timeout counter.
 664:	0e 94 8a 05 	call	0xb14	; 0xb14 <stepperIncrementTimeoutCount>
	TCB1.INTFLAGS = TCB_CAPT_bm;		//Clear the interrupt flag.
 668:	81 e0       	ldi	r24, 0x01	; 1
 66a:	80 93 16 0b 	sts	0x0B16, r24	; 0x800b16 <__RODATA_PM_OFFSET__+0x7f8b16>
 66e:	ff 91       	pop	r31
 670:	ef 91       	pop	r30
 672:	bf 91       	pop	r27
 674:	af 91       	pop	r26
 676:	9f 91       	pop	r25
 678:	8f 91       	pop	r24
 67a:	7f 91       	pop	r23
 67c:	6f 91       	pop	r22
 67e:	5f 91       	pop	r21
 680:	4f 91       	pop	r20
 682:	3f 91       	pop	r19
 684:	2f 91       	pop	r18
 686:	0f 90       	pop	r0
 688:	0f be       	out	0x3f, r0	; 63
 68a:	0f 90       	pop	r0
 68c:	1f 90       	pop	r1
 68e:	18 95       	reti

00000690 <main>:


int main(void)
{	
	/*Enable global interrupts*/
	sei();											
 690:	78 94       	sei

	/*Configure system clock*/
	systemClockConfig();
 692:	0e 94 2e 06 	call	0xc5c	; 0xc5c <systemClockConfig>
	
	/*Configure pins in each port*/
	systemPortAConfig();
 696:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <systemPortAConfig>
	systemPortCConfig();
 69a:	0e 94 05 06 	call	0xc0a	; 0xc0a <systemPortCConfig>
	systemPortDConfig();
 69e:	0e 94 17 06 	call	0xc2e	; 0xc2e <systemPortDConfig>
	systemPortFConfig();
 6a2:	0e 94 26 06 	call	0xc4c	; 0xc4c <systemPortFConfig>
	
	/*Enable TCA0 which is used as a source for TCBx*/
	systemEnableTCA0();
 6a6:	0e 94 64 06 	call	0xcc8	; 0xcc8 <systemEnableTCA0>

	/*Configure ADC to read car battery/stepper supply voltage*/
	systemConfigADC();
 6aa:	0e 94 37 06 	call	0xc6e	; 0xc6e <systemConfigADC>
	
	/*Load default stepper settings*/
	stepperInit();
 6ae:	0e 94 48 05 	call	0xa90	; 0xa90 <stepperInit>
		
	/*Wait until the correct position is written from the master.*/
	while ((stepperPosition() == -1) || (stepperSetPoint() == -1)) 
 6b2:	05 c0       	rjmp	.+10     	; 0x6be <main+0x2e>
	{
		if ((stepperFlags() & FLAG_GO_TO_ZERO_bm) != 0)
 6b4:	0e 94 a3 05 	call	0xb46	; 0xb46 <stepperFlags>
 6b8:	83 fd       	sbrc	r24, 3
		{
			stepperGoToZero();
 6ba:	0e 94 a9 05 	call	0xb52	; 0xb52 <stepperGoToZero>
	
	/*Load default stepper settings*/
	stepperInit();
		
	/*Wait until the correct position is written from the master.*/
	while ((stepperPosition() == -1) || (stepperSetPoint() == -1)) 
 6be:	0e 94 2b 05 	call	0xa56	; 0xa56 <stepperPosition>
 6c2:	01 96       	adiw	r24, 0x01	; 1
 6c4:	b9 f3       	breq	.-18     	; 0x6b4 <main+0x24>
 6c6:	0e 94 32 05 	call	0xa64	; 0xa64 <stepperSetPoint>
 6ca:	01 96       	adiw	r24, 0x01	; 1
 6cc:	99 f3       	breq	.-26     	; 0x6b4 <main+0x24>
 6ce:	16 c0       	rjmp	.+44     	; 0x6fc <main+0x6c>
    while (1) 
    {
		/*While the stepper position is not equal to the set point*/
		while (stepperAtSetPoint() == 0)					
		{
			if (stepperPosition() < stepperSetPoint())
 6d0:	0e 94 2b 05 	call	0xa56	; 0xa56 <stepperPosition>
 6d4:	ec 01       	movw	r28, r24
 6d6:	0e 94 32 05 	call	0xa64	; 0xa64 <stepperSetPoint>
 6da:	c8 17       	cp	r28, r24
 6dc:	d9 07       	cpc	r29, r25
 6de:	24 f4       	brge	.+8      	; 0x6e8 <main+0x58>
			{
				stepperSetDirection(DIRECTION_CW);
 6e0:	8f ef       	ldi	r24, 0xFF	; 255
 6e2:	0e 94 a2 04 	call	0x944	; 0x944 <stepperSetDirection>
 6e6:	03 c0       	rjmp	.+6      	; 0x6ee <main+0x5e>
			} 
			else
			{
				stepperSetDirection(DIRECTION_CCW);
 6e8:	81 e0       	ldi	r24, 0x01	; 1
 6ea:	0e 94 a2 04 	call	0x944	; 0x944 <stepperSetDirection>
			}
			stepperStartMove();
 6ee:	0e 94 90 03 	call	0x720	; 0x720 <stepperStartMove>
			STEPPER_ENABLE;
 6f2:	e0 e4       	ldi	r30, 0x40	; 64
 6f4:	f4 e0       	ldi	r31, 0x04	; 4
 6f6:	84 81       	ldd	r24, Z+4	; 0x04
 6f8:	8b 7f       	andi	r24, 0xFB	; 251
 6fa:	84 83       	std	Z+4, r24	; 0x04
	}
	
    while (1) 
    {
		/*While the stepper position is not equal to the set point*/
		while (stepperAtSetPoint() == 0)					
 6fc:	0e 94 1c 05 	call	0xa38	; 0xa38 <stepperAtSetPoint>
 700:	88 23       	and	r24, r24
 702:	31 f3       	breq	.-52     	; 0x6d0 <main+0x40>
			stepperStartMove();
			STEPPER_ENABLE;
		}
		
		/*When the stepper position is equal to the set point*/
		STEPPER_DISABLE;
 704:	e0 e4       	ldi	r30, 0x40	; 64
 706:	f4 e0       	ldi	r31, 0x04	; 4
 708:	84 81       	ldd	r24, Z+4	; 0x04
 70a:	84 60       	ori	r24, 0x04	; 4
 70c:	84 83       	std	Z+4, r24	; 0x04
		stepperStopMove();
 70e:	0e 94 68 04 	call	0x8d0	; 0x8d0 <stepperStopMove>
		
		
		/*If the go to zero flag is set run the go to zero function*/
		if ((stepperFlags() & FLAG_GO_TO_ZERO_bm) != 0)
 712:	0e 94 a3 05 	call	0xb46	; 0xb46 <stepperFlags>
 716:	83 ff       	sbrs	r24, 3
 718:	f1 cf       	rjmp	.-30     	; 0x6fc <main+0x6c>
		{
			stepperGoToZero();
 71a:	0e 94 a9 05 	call	0xb52	; 0xb52 <stepperGoToZero>
 71e:	ee cf       	rjmp	.-36     	; 0x6fc <main+0x6c>

00000720 <stepperStartMove>:
		{
			return 1;
		}
	}
	return 0;
}
 720:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 724:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 728:	86 81       	ldd	r24, Z+6	; 0x06
 72a:	82 30       	cpi	r24, 0x02	; 2
 72c:	f1 f1       	breq	.+124    	; 0x7aa <stepperStartMove+0x8a>
 72e:	2c f4       	brge	.+10     	; 0x73a <stepperStartMove+0x1a>
 730:	88 23       	and	r24, r24
 732:	61 f0       	breq	.+24     	; 0x74c <stepperStartMove+0x2c>
 734:	81 30       	cpi	r24, 0x01	; 1
 736:	01 f1       	breq	.+64     	; 0x778 <stepperStartMove+0x58>
 738:	9c c0       	rjmp	.+312    	; 0x872 <stepperStartMove+0x152>
 73a:	84 30       	cpi	r24, 0x04	; 4
 73c:	09 f4       	brne	.+2      	; 0x740 <stepperStartMove+0x20>
 73e:	67 c0       	rjmp	.+206    	; 0x80e <stepperStartMove+0xee>
 740:	0c f4       	brge	.+2      	; 0x744 <stepperStartMove+0x24>
 742:	4c c0       	rjmp	.+152    	; 0x7dc <stepperStartMove+0xbc>
 744:	85 30       	cpi	r24, 0x05	; 5
 746:	09 f4       	brne	.+2      	; 0x74a <stepperStartMove+0x2a>
 748:	7b c0       	rjmp	.+246    	; 0x840 <stepperStartMove+0x120>
 74a:	93 c0       	rjmp	.+294    	; 0x872 <stepperStartMove+0x152>
 74c:	82 85       	ldd	r24, Z+10	; 0x0a
 74e:	93 85       	ldd	r25, Z+11	; 0x0b
 750:	48 ec       	ldi	r20, 0xC8	; 200
 752:	48 9f       	mul	r20, r24
 754:	90 01       	movw	r18, r0
 756:	49 9f       	mul	r20, r25
 758:	30 0d       	add	r19, r0
 75a:	11 24       	eor	r1, r1
 75c:	a9 e8       	ldi	r26, 0x89	; 137
 75e:	b8 e8       	ldi	r27, 0x88	; 136
 760:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__umulhisi3>
 764:	bc 01       	movw	r22, r24
 766:	76 95       	lsr	r23
 768:	67 95       	ror	r22
 76a:	72 95       	swap	r23
 76c:	62 95       	swap	r22
 76e:	6f 70       	andi	r22, 0x0F	; 15
 770:	67 27       	eor	r22, r23
 772:	7f 70       	andi	r23, 0x0F	; 15
 774:	67 27       	eor	r22, r23
 776:	7f c0       	rjmp	.+254    	; 0x876 <stepperStartMove+0x156>
 778:	42 85       	ldd	r20, Z+10	; 0x0a
 77a:	53 85       	ldd	r21, Z+11	; 0x0b
 77c:	80 e9       	ldi	r24, 0x90	; 144
 77e:	91 e0       	ldi	r25, 0x01	; 1
 780:	48 9f       	mul	r20, r24
 782:	90 01       	movw	r18, r0
 784:	49 9f       	mul	r20, r25
 786:	30 0d       	add	r19, r0
 788:	58 9f       	mul	r21, r24
 78a:	30 0d       	add	r19, r0
 78c:	11 24       	eor	r1, r1
 78e:	a9 e8       	ldi	r26, 0x89	; 137
 790:	b8 e8       	ldi	r27, 0x88	; 136
 792:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__umulhisi3>
 796:	bc 01       	movw	r22, r24
 798:	76 95       	lsr	r23
 79a:	67 95       	ror	r22
 79c:	72 95       	swap	r23
 79e:	62 95       	swap	r22
 7a0:	6f 70       	andi	r22, 0x0F	; 15
 7a2:	67 27       	eor	r22, r23
 7a4:	7f 70       	andi	r23, 0x0F	; 15
 7a6:	67 27       	eor	r22, r23
 7a8:	66 c0       	rjmp	.+204    	; 0x876 <stepperStartMove+0x156>
 7aa:	42 85       	ldd	r20, Z+10	; 0x0a
 7ac:	53 85       	ldd	r21, Z+11	; 0x0b
 7ae:	80 e2       	ldi	r24, 0x20	; 32
 7b0:	93 e0       	ldi	r25, 0x03	; 3
 7b2:	48 9f       	mul	r20, r24
 7b4:	90 01       	movw	r18, r0
 7b6:	49 9f       	mul	r20, r25
 7b8:	30 0d       	add	r19, r0
 7ba:	58 9f       	mul	r21, r24
 7bc:	30 0d       	add	r19, r0
 7be:	11 24       	eor	r1, r1
 7c0:	a9 e8       	ldi	r26, 0x89	; 137
 7c2:	b8 e8       	ldi	r27, 0x88	; 136
 7c4:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__umulhisi3>
 7c8:	bc 01       	movw	r22, r24
 7ca:	76 95       	lsr	r23
 7cc:	67 95       	ror	r22
 7ce:	72 95       	swap	r23
 7d0:	62 95       	swap	r22
 7d2:	6f 70       	andi	r22, 0x0F	; 15
 7d4:	67 27       	eor	r22, r23
 7d6:	7f 70       	andi	r23, 0x0F	; 15
 7d8:	67 27       	eor	r22, r23
 7da:	4d c0       	rjmp	.+154    	; 0x876 <stepperStartMove+0x156>
 7dc:	42 85       	ldd	r20, Z+10	; 0x0a
 7de:	53 85       	ldd	r21, Z+11	; 0x0b
 7e0:	80 e4       	ldi	r24, 0x40	; 64
 7e2:	96 e0       	ldi	r25, 0x06	; 6
 7e4:	48 9f       	mul	r20, r24
 7e6:	90 01       	movw	r18, r0
 7e8:	49 9f       	mul	r20, r25
 7ea:	30 0d       	add	r19, r0
 7ec:	58 9f       	mul	r21, r24
 7ee:	30 0d       	add	r19, r0
 7f0:	11 24       	eor	r1, r1
 7f2:	a9 e8       	ldi	r26, 0x89	; 137
 7f4:	b8 e8       	ldi	r27, 0x88	; 136
 7f6:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__umulhisi3>
 7fa:	bc 01       	movw	r22, r24
 7fc:	76 95       	lsr	r23
 7fe:	67 95       	ror	r22
 800:	72 95       	swap	r23
 802:	62 95       	swap	r22
 804:	6f 70       	andi	r22, 0x0F	; 15
 806:	67 27       	eor	r22, r23
 808:	7f 70       	andi	r23, 0x0F	; 15
 80a:	67 27       	eor	r22, r23
 80c:	34 c0       	rjmp	.+104    	; 0x876 <stepperStartMove+0x156>
 80e:	42 85       	ldd	r20, Z+10	; 0x0a
 810:	53 85       	ldd	r21, Z+11	; 0x0b
 812:	80 e8       	ldi	r24, 0x80	; 128
 814:	9c e0       	ldi	r25, 0x0C	; 12
 816:	48 9f       	mul	r20, r24
 818:	90 01       	movw	r18, r0
 81a:	49 9f       	mul	r20, r25
 81c:	30 0d       	add	r19, r0
 81e:	58 9f       	mul	r21, r24
 820:	30 0d       	add	r19, r0
 822:	11 24       	eor	r1, r1
 824:	a9 e8       	ldi	r26, 0x89	; 137
 826:	b8 e8       	ldi	r27, 0x88	; 136
 828:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__umulhisi3>
 82c:	bc 01       	movw	r22, r24
 82e:	76 95       	lsr	r23
 830:	67 95       	ror	r22
 832:	72 95       	swap	r23
 834:	62 95       	swap	r22
 836:	6f 70       	andi	r22, 0x0F	; 15
 838:	67 27       	eor	r22, r23
 83a:	7f 70       	andi	r23, 0x0F	; 15
 83c:	67 27       	eor	r22, r23
 83e:	1b c0       	rjmp	.+54     	; 0x876 <stepperStartMove+0x156>
 840:	42 85       	ldd	r20, Z+10	; 0x0a
 842:	53 85       	ldd	r21, Z+11	; 0x0b
 844:	80 e0       	ldi	r24, 0x00	; 0
 846:	99 e1       	ldi	r25, 0x19	; 25
 848:	48 9f       	mul	r20, r24
 84a:	90 01       	movw	r18, r0
 84c:	49 9f       	mul	r20, r25
 84e:	30 0d       	add	r19, r0
 850:	58 9f       	mul	r21, r24
 852:	30 0d       	add	r19, r0
 854:	11 24       	eor	r1, r1
 856:	a9 e8       	ldi	r26, 0x89	; 137
 858:	b8 e8       	ldi	r27, 0x88	; 136
 85a:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__umulhisi3>
 85e:	bc 01       	movw	r22, r24
 860:	76 95       	lsr	r23
 862:	67 95       	ror	r22
 864:	72 95       	swap	r23
 866:	62 95       	swap	r22
 868:	6f 70       	andi	r22, 0x0F	; 15
 86a:	67 27       	eor	r22, r23
 86c:	7f 70       	andi	r23, 0x0F	; 15
 86e:	67 27       	eor	r22, r23
 870:	02 c0       	rjmp	.+4      	; 0x876 <stepperStartMove+0x156>
 872:	60 e0       	ldi	r22, 0x00	; 0
 874:	70 e0       	ldi	r23, 0x00	; 0
 876:	61 15       	cp	r22, r1
 878:	71 05       	cpc	r23, r1
 87a:	21 f4       	brne	.+8      	; 0x884 <stepperStartMove+0x164>
 87c:	85 85       	ldd	r24, Z+13	; 0x0d
 87e:	84 60       	ori	r24, 0x04	; 4
 880:	85 87       	std	Z+13, r24	; 0x0d
 882:	08 95       	ret
 884:	8d e8       	ldi	r24, 0x8D	; 141
 886:	9b e5       	ldi	r25, 0x5B	; 91
 888:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__udivmodhi4>
 88c:	e0 e2       	ldi	r30, 0x20	; 32
 88e:	fb e0       	ldi	r31, 0x0B	; 11
 890:	64 87       	std	Z+12, r22	; 0x0c
 892:	66 95       	lsr	r22
 894:	65 87       	std	Z+13, r22	; 0x0d
 896:	80 81       	ld	r24, Z
 898:	81 60       	ori	r24, 0x01	; 1
 89a:	80 83       	st	Z, r24
 89c:	08 95       	ret

0000089e <stepperSetStepMode>:
 89e:	a0 91 06 70 	lds	r26, 0x7006	; 0x807006 <pMotor>
 8a2:	b0 91 07 70 	lds	r27, 0x7007	; 0x807007 <pMotor+0x1>
 8a6:	16 96       	adiw	r26, 0x06	; 6
 8a8:	8c 93       	st	X, r24
 8aa:	16 97       	sbiw	r26, 0x06	; 6
 8ac:	e0 e6       	ldi	r30, 0x60	; 96
 8ae:	f4 e0       	ldi	r31, 0x04	; 4
 8b0:	84 81       	ldd	r24, Z+4	; 0x04
 8b2:	88 7f       	andi	r24, 0xF8	; 248
 8b4:	84 83       	std	Z+4, r24	; 0x04
 8b6:	94 81       	ldd	r25, Z+4	; 0x04
 8b8:	16 96       	adiw	r26, 0x06	; 6
 8ba:	8c 91       	ld	r24, X
 8bc:	89 2b       	or	r24, r25
 8be:	84 83       	std	Z+4, r24	; 0x04
 8c0:	08 95       	ret

000008c2 <stepperSetSpeed>:
 8c2:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 8c6:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 8ca:	82 87       	std	Z+10, r24	; 0x0a
 8cc:	93 87       	std	Z+11, r25	; 0x0b
 8ce:	08 95       	ret

000008d0 <stepperStopMove>:
 8d0:	e0 e2       	ldi	r30, 0x20	; 32
 8d2:	fb e0       	ldi	r31, 0x0B	; 11
 8d4:	80 81       	ld	r24, Z
 8d6:	8e 7f       	andi	r24, 0xFE	; 254
 8d8:	80 83       	st	Z, r24
 8da:	08 95       	ret

000008dc <stepperIncrementPosition>:
 8dc:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 8e0:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 8e4:	20 81       	ld	r18, Z
 8e6:	31 81       	ldd	r19, Z+1	; 0x01
 8e8:	22 83       	std	Z+2, r18	; 0x02
 8ea:	33 83       	std	Z+3, r19	; 0x03
 8ec:	28 0f       	add	r18, r24
 8ee:	31 1d       	adc	r19, r1
 8f0:	87 fd       	sbrc	r24, 7
 8f2:	3a 95       	dec	r19
 8f4:	20 83       	st	Z, r18
 8f6:	31 83       	std	Z+1, r19	; 0x01
 8f8:	08 95       	ret

000008fa <stepperSetDecay>:
 8fa:	e0 e6       	ldi	r30, 0x60	; 96
 8fc:	f4 e0       	ldi	r31, 0x04	; 4
 8fe:	90 81       	ld	r25, Z
 900:	90 68       	ori	r25, 0x80	; 128
 902:	90 83       	st	Z, r25
 904:	17 8a       	std	Z+23, r1	; 0x17
 906:	81 30       	cpi	r24, 0x01	; 1
 908:	19 f0       	breq	.+6      	; 0x910 <stepperSetDecay+0x16>
 90a:	82 30       	cpi	r24, 0x02	; 2
 90c:	39 f0       	breq	.+14     	; 0x91c <stepperSetDecay+0x22>
 90e:	0c c0       	rjmp	.+24     	; 0x928 <stepperSetDecay+0x2e>
 910:	e0 e6       	ldi	r30, 0x60	; 96
 912:	f4 e0       	ldi	r31, 0x04	; 4
 914:	94 81       	ldd	r25, Z+4	; 0x04
 916:	90 68       	ori	r25, 0x80	; 128
 918:	94 83       	std	Z+4, r25	; 0x04
 91a:	0e c0       	rjmp	.+28     	; 0x938 <stepperSetDecay+0x3e>
 91c:	e0 e6       	ldi	r30, 0x60	; 96
 91e:	f4 e0       	ldi	r31, 0x04	; 4
 920:	94 81       	ldd	r25, Z+4	; 0x04
 922:	9f 77       	andi	r25, 0x7F	; 127
 924:	94 83       	std	Z+4, r25	; 0x04
 926:	08 c0       	rjmp	.+16     	; 0x938 <stepperSetDecay+0x3e>
 928:	e0 e6       	ldi	r30, 0x60	; 96
 92a:	f4 e0       	ldi	r31, 0x04	; 4
 92c:	80 81       	ld	r24, Z
 92e:	8f 77       	andi	r24, 0x7F	; 127
 930:	80 83       	st	Z, r24
 932:	84 e0       	ldi	r24, 0x04	; 4
 934:	87 8b       	std	Z+23, r24	; 0x17
 936:	80 e0       	ldi	r24, 0x00	; 0
 938:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 93c:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 940:	81 87       	std	Z+9, r24	; 0x09
 942:	08 95       	ret

00000944 <stepperSetDirection>:
 944:	81 30       	cpi	r24, 0x01	; 1
 946:	31 f4       	brne	.+12     	; 0x954 <stepperSetDirection+0x10>
 948:	e0 e4       	ldi	r30, 0x40	; 64
 94a:	f4 e0       	ldi	r31, 0x04	; 4
 94c:	84 81       	ldd	r24, Z+4	; 0x04
 94e:	82 60       	ori	r24, 0x02	; 2
 950:	84 83       	std	Z+4, r24	; 0x04
 952:	08 95       	ret
 954:	e0 e4       	ldi	r30, 0x40	; 64
 956:	f4 e0       	ldi	r31, 0x04	; 4
 958:	84 81       	ldd	r24, Z+4	; 0x04
 95a:	8d 7f       	andi	r24, 0xFD	; 253
 95c:	84 83       	std	Z+4, r24	; 0x04
 95e:	08 95       	ret

00000960 <stepperSetCurrent>:
 960:	9c 01       	movw	r18, r24
 962:	21 50       	subi	r18, 0x01	; 1
 964:	31 09       	sbc	r19, r1
 966:	2e 3f       	cpi	r18, 0xFE	; 254
 968:	33 40       	sbci	r19, 0x03	; 3
 96a:	38 f4       	brcc	.+14     	; 0x97a <stepperSetCurrent+0x1a>
 96c:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 970:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 974:	87 83       	std	Z+7, r24	; 0x07
 976:	90 87       	std	Z+8, r25	; 0x08
 978:	08 c0       	rjmp	.+16     	; 0x98a <stepperSetCurrent+0x2a>
 97a:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 97e:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 982:	83 e3       	ldi	r24, 0x33	; 51
 984:	91 e0       	ldi	r25, 0x01	; 1
 986:	87 83       	std	Z+7, r24	; 0x07
 988:	90 87       	std	Z+8, r25	; 0x08
 98a:	e0 ea       	ldi	r30, 0xA0	; 160
 98c:	f6 e0       	ldi	r31, 0x06	; 6
 98e:	10 82       	st	Z, r1
 990:	a0 91 06 70 	lds	r26, 0x7006	; 0x807006 <pMotor>
 994:	b0 91 07 70 	lds	r27, 0x7007	; 0x807007 <pMotor+0x1>
 998:	17 96       	adiw	r26, 0x07	; 7
 99a:	8d 91       	ld	r24, X+
 99c:	9c 91       	ld	r25, X
 99e:	18 97       	sbiw	r26, 0x08	; 8
 9a0:	00 24       	eor	r0, r0
 9a2:	96 95       	lsr	r25
 9a4:	87 95       	ror	r24
 9a6:	07 94       	ror	r0
 9a8:	96 95       	lsr	r25
 9aa:	87 95       	ror	r24
 9ac:	07 94       	ror	r0
 9ae:	98 2f       	mov	r25, r24
 9b0:	80 2d       	mov	r24, r0
 9b2:	1e 96       	adiw	r26, 0x0e	; 14
 9b4:	8d 93       	st	X+, r24
 9b6:	9c 93       	st	X, r25
 9b8:	1f 97       	sbiw	r26, 0x0f	; 15
 9ba:	82 83       	std	Z+2, r24	; 0x02
 9bc:	1f 96       	adiw	r26, 0x0f	; 15
 9be:	8c 91       	ld	r24, X
 9c0:	83 83       	std	Z+3, r24	; 0x03
 9c2:	81 e4       	ldi	r24, 0x41	; 65
 9c4:	80 83       	st	Z, r24
 9c6:	08 95       	ret

000009c8 <stepperSetSetPoint>:
 9c8:	6a e0       	ldi	r22, 0x0A	; 10
 9ca:	70 e0       	ldi	r23, 0x00	; 0
 9cc:	0e 94 8d 06 	call	0xd1a	; 0xd1a <__divmodhi4>
 9d0:	cb 01       	movw	r24, r22
 9d2:	88 0f       	add	r24, r24
 9d4:	99 1f       	adc	r25, r25
 9d6:	66 0f       	add	r22, r22
 9d8:	77 1f       	adc	r23, r23
 9da:	66 0f       	add	r22, r22
 9dc:	77 1f       	adc	r23, r23
 9de:	66 0f       	add	r22, r22
 9e0:	77 1f       	adc	r23, r23
 9e2:	68 0f       	add	r22, r24
 9e4:	79 1f       	adc	r23, r25
 9e6:	6d 32       	cpi	r22, 0x2D	; 45
 9e8:	81 e0       	ldi	r24, 0x01	; 1
 9ea:	78 07       	cpc	r23, r24
 9ec:	30 f4       	brcc	.+12     	; 0x9fa <stepperSetSetPoint+0x32>
 9ee:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 9f2:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 9f6:	64 83       	std	Z+4, r22	; 0x04
 9f8:	75 83       	std	Z+5, r23	; 0x05
 9fa:	08 95       	ret

000009fc <stepperSetPosition>:
 9fc:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 a00:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 a04:	20 81       	ld	r18, Z
 a06:	31 81       	ldd	r19, Z+1	; 0x01
 a08:	22 83       	std	Z+2, r18	; 0x02
 a0a:	33 83       	std	Z+3, r19	; 0x03
 a0c:	6a e0       	ldi	r22, 0x0A	; 10
 a0e:	70 e0       	ldi	r23, 0x00	; 0
 a10:	0e 94 8d 06 	call	0xd1a	; 0xd1a <__divmodhi4>
 a14:	cb 01       	movw	r24, r22
 a16:	88 0f       	add	r24, r24
 a18:	99 1f       	adc	r25, r25
 a1a:	66 0f       	add	r22, r22
 a1c:	77 1f       	adc	r23, r23
 a1e:	66 0f       	add	r22, r22
 a20:	77 1f       	adc	r23, r23
 a22:	66 0f       	add	r22, r22
 a24:	77 1f       	adc	r23, r23
 a26:	68 0f       	add	r22, r24
 a28:	79 1f       	adc	r23, r25
 a2a:	6d 32       	cpi	r22, 0x2D	; 45
 a2c:	81 e0       	ldi	r24, 0x01	; 1
 a2e:	78 07       	cpc	r23, r24
 a30:	10 f4       	brcc	.+4      	; 0xa36 <stepperSetPosition+0x3a>
 a32:	60 83       	st	Z, r22
 a34:	71 83       	std	Z+1, r23	; 0x01
 a36:	08 95       	ret

00000a38 <stepperAtSetPoint>:
 a38:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 a3c:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 a40:	20 81       	ld	r18, Z
 a42:	31 81       	ldd	r19, Z+1	; 0x01
 a44:	84 81       	ldd	r24, Z+4	; 0x04
 a46:	95 81       	ldd	r25, Z+5	; 0x05
 a48:	28 17       	cp	r18, r24
 a4a:	39 07       	cpc	r19, r25
 a4c:	11 f4       	brne	.+4      	; 0xa52 <stepperAtSetPoint+0x1a>
 a4e:	81 e0       	ldi	r24, 0x01	; 1
 a50:	08 95       	ret
 a52:	80 e0       	ldi	r24, 0x00	; 0
 a54:	08 95       	ret

00000a56 <stepperPosition>:
 a56:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 a5a:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 a5e:	80 81       	ld	r24, Z
 a60:	91 81       	ldd	r25, Z+1	; 0x01
 a62:	08 95       	ret

00000a64 <stepperSetPoint>:
 a64:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 a68:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 a6c:	84 81       	ldd	r24, Z+4	; 0x04
 a6e:	95 81       	ldd	r25, Z+5	; 0x05
 a70:	08 95       	ret

00000a72 <stepperSpeed>:
 a72:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 a76:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 a7a:	82 85       	ldd	r24, Z+10	; 0x0a
 a7c:	93 85       	ldd	r25, Z+11	; 0x0b
 a7e:	08 95       	ret

00000a80 <stepperConfigTimeoutTimer>:
Returns: none
Description: Just configures the TCB thats being used for the timeout counter.
*/
void stepperConfigTimeoutTimer(uint16_t TCB_PER)
{
	systemConfigTCB(stepperTimeoutTimer, TCB_PER);
 a80:	bc 01       	movw	r22, r24
 a82:	80 91 04 70 	lds	r24, 0x7004	; 0x807004 <stepperTimeoutTimer>
 a86:	90 91 05 70 	lds	r25, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 a8a:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <systemConfigTCB>
 a8e:	08 95       	ret

00000a90 <stepperInit>:
			memory.
*/
void stepperInit()
{
	/*Default stepper settings*/
	STEPPER_DISABLE;
 a90:	e0 e4       	ldi	r30, 0x40	; 64
 a92:	f4 e0       	ldi	r31, 0x04	; 4
 a94:	84 81       	ldd	r24, Z+4	; 0x04
 a96:	84 60       	ori	r24, 0x04	; 4
 a98:	84 83       	std	Z+4, r24	; 0x04
	stepperSetCurrent(TWO_AMP_bm);
 a9a:	8a e9       	ldi	r24, 0x9A	; 154
 a9c:	91 e0       	ldi	r25, 0x01	; 1
 a9e:	0e 94 b0 04 	call	0x960	; 0x960 <stepperSetCurrent>
	stepperSetStepMode(MODE_HALF_STEP_bm);
 aa2:	81 e0       	ldi	r24, 0x01	; 1
 aa4:	0e 94 4f 04 	call	0x89e	; 0x89e <stepperSetStepMode>
	stepperSetSpeed(100);
 aa8:	84 e6       	ldi	r24, 0x64	; 100
 aaa:	90 e0       	ldi	r25, 0x00	; 0
 aac:	0e 94 61 04 	call	0x8c2	; 0x8c2 <stepperSetSpeed>
	stepperSetDecay(DECAY_MIXED);
 ab0:	80 e0       	ldi	r24, 0x00	; 0
 ab2:	0e 94 7d 04 	call	0x8fa	; 0x8fa <stepperSetDecay>
	
	/*Configures the TCB used for timeout checking*/
	stepperConfigTimeoutTimer(TCB_PER_1SEC);	
 ab6:	8d e8       	ldi	r24, 0x8D	; 141
 ab8:	9b e5       	ldi	r25, 0x5B	; 91
 aba:	0e 94 40 05 	call	0xa80	; 0xa80 <stepperConfigTimeoutTimer>
	
	/*Have to directly access these because the function won't allow -1*/
	pMotor->position = -1;
 abe:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 ac2:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 ac6:	8f ef       	ldi	r24, 0xFF	; 255
 ac8:	9f ef       	ldi	r25, 0xFF	; 255
 aca:	80 83       	st	Z, r24
 acc:	91 83       	std	Z+1, r25	; 0x01
	pMotor->setPoint = -1;
 ace:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 ad2:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 ad6:	84 83       	std	Z+4, r24	; 0x04
 ad8:	95 83       	std	Z+5, r25	; 0x05
	pMotor->previousPosition = -1;
 ada:	82 83       	std	Z+2, r24	; 0x02
 adc:	93 83       	std	Z+3, r25	; 0x03
 ade:	08 95       	ret

00000ae0 <stepperStartTimeoutTimer>:
Returns: none
Description: The timeout timer starts counting.
*/
void stepperStartTimeoutTimer()
{
	systemEnableTCB(stepperTimeoutTimer);
 ae0:	80 91 04 70 	lds	r24, 0x7004	; 0x807004 <stepperTimeoutTimer>
 ae4:	90 91 05 70 	lds	r25, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 ae8:	0e 94 6f 06 	call	0xcde	; 0xcde <systemEnableTCB>
 aec:	08 95       	ret

00000aee <stepperClearTimeoutTimer>:
Description: Clears the count register for the actual timer and resets
			the timeoutCounter struct member to zero.
*/
void stepperClearTimeoutTimer()
{
	stepperTimeoutTimer->CNT = 0;
 aee:	e0 91 04 70 	lds	r30, 0x7004	; 0x807004 <stepperTimeoutTimer>
 af2:	f0 91 05 70 	lds	r31, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 af6:	12 86       	std	Z+10, r1	; 0x0a
 af8:	13 86       	std	Z+11, r1	; 0x0b
	pMotor->timeoutCounter = 0;
 afa:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 afe:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b02:	14 86       	std	Z+12, r1	; 0x0c
 b04:	08 95       	ret

00000b06 <stepperStopTimeoutTimer>:
Returns: none
Description: Disables the timer.
*/
void stepperStopTimeoutTimer()
{
	systemDisableTCB(stepperTimeoutTimer);
 b06:	80 91 04 70 	lds	r24, 0x7004	; 0x807004 <stepperTimeoutTimer>
 b0a:	90 91 05 70 	lds	r25, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 b0e:	0e 94 74 06 	call	0xce8	; 0xce8 <systemDisableTCB>
 b12:	08 95       	ret

00000b14 <stepperIncrementTimeoutCount>:
Returns: none
Description: Increments the member of stepper_info "timeoutCounter".
*/
void stepperIncrementTimeoutCount()
{
	pMotor->timeoutCounter++;
 b14:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b18:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b1c:	84 85       	ldd	r24, Z+12	; 0x0c
 b1e:	8f 5f       	subi	r24, 0xFF	; 255
 b20:	84 87       	std	Z+12, r24	; 0x0c
 b22:	08 95       	ret

00000b24 <stepperSetFlag>:
Returns: none
Description: Applies a bitmask to "flags" in stepper_info.
*/
void stepperSetFlag(uint8_t flag_bm)
{
	pMotor->flags |= flag_bm;
 b24:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b28:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b2c:	95 85       	ldd	r25, Z+13	; 0x0d
 b2e:	89 2b       	or	r24, r25
 b30:	85 87       	std	Z+13, r24	; 0x0d
 b32:	08 95       	ret

00000b34 <stepperClearFlag>:
Returns:
Description: Clears a bit from "flags". Member in stepper_info.
*/
void stepperClearFlag(uint8_t flag_bm)
{
	pMotor->flags &= ~(flag_bm);
 b34:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b38:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b3c:	80 95       	com	r24
 b3e:	95 85       	ldd	r25, Z+13	; 0x0d
 b40:	89 23       	and	r24, r25
 b42:	85 87       	std	Z+13, r24	; 0x0d
 b44:	08 95       	ret

00000b46 <stepperFlags>:
Description: Returns the variable flags from stepper_info. Can be compared against the 
			bitmasks at the top of stepper.h
*/
uint8_t stepperFlags()
{
	return pMotor->flags;
 b46:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b4a:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
}
 b4e:	85 85       	ldd	r24, Z+13	; 0x0d
 b50:	08 95       	ret

00000b52 <stepperGoToZero>:
*/
void stepperGoToZero()
{
	bool motorIsMoving = true;
	
	stepperSetDirection(DIRECTION_CCW);								//Set direction to count down towards soft
 b52:	81 e0       	ldi	r24, 0x01	; 1
 b54:	0e 94 a2 04 	call	0x944	; 0x944 <stepperSetDirection>
	stepperStartMove();												//Start the stepper PWM signal
 b58:	0e 94 90 03 	call	0x720	; 0x720 <stepperStartMove>
	STEPPER_ENABLE;													//Enable the driver.
 b5c:	e0 e4       	ldi	r30, 0x40	; 64
 b5e:	f4 e0       	ldi	r31, 0x04	; 4
 b60:	84 81       	ldd	r24, Z+4	; 0x04
 b62:	8b 7f       	andi	r24, 0xFB	; 251
 b64:	84 83       	std	Z+4, r24	; 0x04
	
	stepperConfigTimeoutTimer(TCB_PER_QUART_SEC);					//Set the period of the timeout timer.
 b66:	83 ee       	ldi	r24, 0xE3	; 227
 b68:	96 e1       	ldi	r25, 0x16	; 22
 b6a:	0e 94 40 05 	call	0xa80	; 0xa80 <stepperConfigTimeoutTimer>
	stepperClearTimeoutTimer();										//Clear the timer count if there is one.
 b6e:	0e 94 77 05 	call	0xaee	; 0xaee <stepperClearTimeoutTimer>
	stepperStartTimeoutTimer();										//Start counter.
 b72:	0e 94 70 05 	call	0xae0	; 0xae0 <stepperStartTimeoutTimer>
			This means the motor can't turn any further and is at position 0.
			Then resets the position and set point to 0.
*/
void stepperGoToZero()
{
	bool motorIsMoving = true;
 b76:	41 e0       	ldi	r20, 0x01	; 1
	
	/*Wait for the timeout flag to be set or for the previous position to be
	greater than the current position. If the motor stops where the encoder
	is on an edge it will keep firing the encoder interrupt and resetting the
	timeoutCounter.*/
	while (motorIsMoving == true) 
 b78:	10 c0       	rjmp	.+32     	; 0xb9a <stepperGoToZero+0x48>
	{
		if (pMotor->timeoutCounter >= 2)
 b7a:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b7e:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b82:	84 85       	ldd	r24, Z+12	; 0x0c
 b84:	82 30       	cpi	r24, 0x02	; 2
 b86:	08 f0       	brcs	.+2      	; 0xb8a <stepperGoToZero+0x38>
		{
			motorIsMoving = false;
 b88:	40 e0       	ldi	r20, 0x00	; 0
		}
		if (pMotor->previousPosition < pMotor->position)
 b8a:	22 81       	ldd	r18, Z+2	; 0x02
 b8c:	33 81       	ldd	r19, Z+3	; 0x03
 b8e:	80 81       	ld	r24, Z
 b90:	91 81       	ldd	r25, Z+1	; 0x01
 b92:	28 17       	cp	r18, r24
 b94:	39 07       	cpc	r19, r25
 b96:	0c f4       	brge	.+2      	; 0xb9a <stepperGoToZero+0x48>
		{
			motorIsMoving = false;
 b98:	40 e0       	ldi	r20, 0x00	; 0
	
	/*Wait for the timeout flag to be set or for the previous position to be
	greater than the current position. If the motor stops where the encoder
	is on an edge it will keep firing the encoder interrupt and resetting the
	timeoutCounter.*/
	while (motorIsMoving == true) 
 b9a:	41 11       	cpse	r20, r1
 b9c:	ee cf       	rjmp	.-36     	; 0xb7a <stepperGoToZero+0x28>
			motorIsMoving = false;
		}
		
	}							
	
	stepperStopTimeoutTimer();										//Stop the timer.
 b9e:	0e 94 83 05 	call	0xb06	; 0xb06 <stepperStopTimeoutTimer>
	stepperStopMove();												//Stop the motor.
 ba2:	0e 94 68 04 	call	0x8d0	; 0x8d0 <stepperStopMove>
	
	stepperSetSetPoint(0);											//Change the current set point.
 ba6:	80 e0       	ldi	r24, 0x00	; 0
 ba8:	90 e0       	ldi	r25, 0x00	; 0
 baa:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <stepperSetSetPoint>
	stepperSetPosition(0);											//Change the current position.
 bae:	80 e0       	ldi	r24, 0x00	; 0
 bb0:	90 e0       	ldi	r25, 0x00	; 0
 bb2:	0e 94 fe 04 	call	0x9fc	; 0x9fc <stepperSetPosition>
	stepperClearFlag(FLAG_GO_TO_ZERO_bm);							//Clear the flag.
 bb6:	88 e0       	ldi	r24, 0x08	; 8
 bb8:	0e 94 9a 05 	call	0xb34	; 0xb34 <stepperClearFlag>
 bbc:	08 95       	ret

00000bbe <stepperCurrentLimit>:
Returns: returns STEPPER_INFO_struct.currentLimit
Description: see returns
*/
CURRENT_LIMIT_t stepperCurrentLimit()
{
	return pMotor->currentLimit;
 bbe:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 bc2:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
}
 bc6:	87 81       	ldd	r24, Z+7	; 0x07
 bc8:	90 85       	ldd	r25, Z+8	; 0x08
 bca:	08 95       	ret

00000bcc <stepperStepMode>:
Returns: STEPPER_INFO_struct.stepMode
Description: see returns
*/
STEP_MODE_t stepperStepMode()
{
	return pMotor->stepMode;
 bcc:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 bd0:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
}
 bd4:	86 81       	ldd	r24, Z+6	; 0x06
 bd6:	08 95       	ret

00000bd8 <systemPortAConfig>:
Description: Configures all the pins in port A.
*/
void systemPortAConfig()
{
	
	PORTA.DIR |= LED1_PIN								//LED Pins as outputs.
 bd8:	e0 e0       	ldi	r30, 0x00	; 0
 bda:	f4 e0       	ldi	r31, 0x04	; 4
 bdc:	80 81       	ld	r24, Z
 bde:	8c 69       	ori	r24, 0x9C	; 156
 be0:	80 83       	st	Z, r24
				| LED2_PIN
				| LED3_PIN
				| CLK_OUT_PIN;							//CLKOUT pin as output.
				
	LED1_OFF;											//Start with all LEDs off.
 be2:	84 81       	ldd	r24, Z+4	; 0x04
 be4:	8b 7f       	andi	r24, 0xFB	; 251
 be6:	84 83       	std	Z+4, r24	; 0x04
	LED2_OFF;
 be8:	84 81       	ldd	r24, Z+4	; 0x04
 bea:	87 7f       	andi	r24, 0xF7	; 247
 bec:	84 83       	std	Z+4, r24	; 0x04
	LED3_OFF;
 bee:	84 81       	ldd	r24, Z+4	; 0x04
 bf0:	8f 7e       	andi	r24, 0xEF	; 239
 bf2:	84 83       	std	Z+4, r24	; 0x04
	
	PORTA.DIR &= ~(ENC_A_PIN							//Encoder pins as input.	
 bf4:	80 81       	ld	r24, Z
 bf6:	8c 7f       	andi	r24, 0xFC	; 252
 bf8:	80 83       	st	Z, r24
				| ENC_B_PIN);
				
	PORTA.PIN0CTRL = PORT_ISC_BOTHEDGES_gc;				//Encoder A pin interrupt enabled.
 bfa:	81 e0       	ldi	r24, 0x01	; 1
 bfc:	80 8b       	std	Z+16, r24	; 0x10
	
	CCP = CCP_IOREG_gc;
 bfe:	88 ed       	ldi	r24, 0xD8	; 216
 c00:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLA = CLKCTRL_CLKOUT_bm;				//Clock out on PA7 (CLK_OUT_PIN)
 c02:	80 e8       	ldi	r24, 0x80	; 128
 c04:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__RODATA_PM_OFFSET__+0x7f8060>
 c08:	08 95       	ret

00000c0a <systemPortCConfig>:
Returns: none
Description: Configures all the pins in port C.
*/
void systemPortCConfig()
{
	PORTC.DIR |= DIR_PIN								//Direction, step, enable, and home pin all outputs.
 c0a:	e0 e4       	ldi	r30, 0x40	; 64
 c0c:	f4 e0       	ldi	r31, 0x04	; 4
 c0e:	80 81       	ld	r24, Z
 c10:	87 60       	ori	r24, 0x07	; 7
 c12:	80 83       	st	Z, r24
				| STEP_PIN
				| nENBL_PIN;
				
	PORTC.OUT &= ~(nENBL_PIN);							//Enable pin low enables the DRV8825.
 c14:	84 81       	ldd	r24, Z+4	; 0x04
 c16:	8b 7f       	andi	r24, 0xFB	; 251
 c18:	84 83       	std	Z+4, r24	; 0x04
				
	PORTC.DIR &= ~nHOME_PIN;							//Home as input.
 c1a:	80 81       	ld	r24, Z
 c1c:	87 7f       	andi	r24, 0xF7	; 247
 c1e:	80 83       	st	Z, r24
	
	TCB2.CTRLB = TCB_CCMPEN_bm							//Waveform will override step pin output.
 c20:	e0 e2       	ldi	r30, 0x20	; 32
 c22:	fb e0       	ldi	r31, 0x0B	; 11
 c24:	87 e1       	ldi	r24, 0x17	; 23
 c26:	81 83       	std	Z+1, r24	; 0x01
				|TCB_CNTMODE_PWM8_gc;					//TCB2 set to 8-bit PWM mode.
	TCB2.CTRLA = TCB_CLKSEL_TCA0_gc;					//TCB2 uses TCA0 as clock source.
 c28:	84 e0       	ldi	r24, 0x04	; 4
 c2a:	80 83       	st	Z, r24
 c2c:	08 95       	ret

00000c2e <systemPortDConfig>:
Returns: none
Description: Configures all the pins in port D.
*/
void systemPortDConfig()
{
	PORTD.DIR |= MODE0_PIN								//Mode pins, reset, sleep, and decay as outputs.
 c2e:	e0 e6       	ldi	r30, 0x60	; 96
 c30:	f4 e0       	ldi	r31, 0x04	; 4
 c32:	80 81       	ld	r24, Z
 c34:	8f 69       	ori	r24, 0x9F	; 159
 c36:	80 83       	st	Z, r24
				| MODE2_PIN
				| nRESET_PIN
				| nSLEEP_PIN
				| DECAY_PIN;
				
	PORTD.OUT |= (nSLEEP_PIN | nRESET_PIN);				//Sleep and reset needed high for DRV8825 operation.
 c38:	84 81       	ldd	r24, Z+4	; 0x04
 c3a:	88 61       	ori	r24, 0x18	; 24
 c3c:	84 83       	std	Z+4, r24	; 0x04
				
	PORTD.DIR &= ~nFAULT_PIN;							//Fault as input.
 c3e:	80 81       	ld	r24, Z
 c40:	8f 7d       	andi	r24, 0xDF	; 223
 c42:	80 83       	st	Z, r24
	
	VREF.DAC0REF = VREF_ALWAYSON_bm						//DAC reference voltage always on for VREF_PIN.
 c44:	83 e8       	ldi	r24, 0x83	; 131
 c46:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__RODATA_PM_OFFSET__+0x7f80a2>
 c4a:	08 95       	ret

00000c4c <systemPortFConfig>:
Returns: none
Description: Configures all the pins in port F.
*/
void systemPortFConfig()
{
	PORTF.DIR &= ~(AIN_12V_PIN | AIN_3V3_PIN);			//Analog pins as inputs
 c4c:	e0 ea       	ldi	r30, 0xA0	; 160
 c4e:	f4 e0       	ldi	r31, 0x04	; 4
 c50:	80 81       	ld	r24, Z
 c52:	8f 7c       	andi	r24, 0xCF	; 207
 c54:	80 83       	st	Z, r24
	iicInit();
 c56:	0e 94 8f 00 	call	0x11e	; 0x11e <iicInit>
 c5a:	08 95       	ret

00000c5c <systemClockConfig>:
Returns: none
Description: Selects the 24MHz clock with no prescaler for the main/master clock.
*/
void systemClockConfig()
{
	CCP = CCP_IOREG_gc;
 c5c:	88 ed       	ldi	r24, 0xD8	; 216
 c5e:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.OSCHFCTRLA = CLKCTRL_FREQSEL_24M_gc			//24MHz frequency.
 c60:	e0 e6       	ldi	r30, 0x60	; 96
 c62:	f0 e0       	ldi	r31, 0x00	; 0
 c64:	95 e2       	ldi	r25, 0x25	; 37
 c66:	90 87       	std	Z+8, r25	; 0x08
					| CLKCTRL_AUTOTUNE_bm;				//Enable autotune.
					
	CCP = CCP_IOREG_gc;					
 c68:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLB = 0;						 		//No prescaler, 24MHz clock.
 c6a:	11 82       	std	Z+1, r1	; 0x01
 c6c:	08 95       	ret

00000c6e <systemConfigADC>:
Returns: none
Description: Configure the ADC to sample the supply voltage.
*/
void systemConfigADC()
{
	VREF.ADC0REF |= VREF_REFSEL_2V500_gc;				//ADC0 reference as 2.5V;	
 c6e:	e0 ea       	ldi	r30, 0xA0	; 160
 c70:	f0 e0       	ldi	r31, 0x00	; 0
 c72:	80 81       	ld	r24, Z
 c74:	83 60       	ori	r24, 0x03	; 3
 c76:	80 83       	st	Z, r24
	ADC0.CTRLA |= ADC_RESSEL_12BIT_gc					//12 bit conversions.
 c78:	e0 e0       	ldi	r30, 0x00	; 0
 c7a:	f6 e0       	ldi	r31, 0x06	; 6
 c7c:	80 81       	ld	r24, Z
 c7e:	82 60       	ori	r24, 0x02	; 2
 c80:	80 83       	st	Z, r24
				| ADC_FREERUN_bm;						//Enable freerunning mode.
	ADC0.CTRLC |= ADC_PRESC_DIV256_gc;					//ADC clock equals system clock div 2.
 c82:	82 81       	ldd	r24, Z+2	; 0x02
 c84:	8d 60       	ori	r24, 0x0D	; 13
 c86:	82 83       	std	Z+2, r24	; 0x02
	ADC0.SAMPCTRL = 20;									//Set sample length to 20 ADC cycles.
 c88:	84 e1       	ldi	r24, 0x14	; 20
 c8a:	85 83       	std	Z+5, r24	; 0x05
	ADC0.CTRLE = ADC_WINCM_BELOW_gc;					//Compare mode set to below.
 c8c:	81 e0       	ldi	r24, 0x01	; 1
 c8e:	84 83       	std	Z+4, r24	; 0x04
	ADC0.MUXPOS = ADC_MUXPOS_AIN21_gc;					//Battery voltage divider is on PF5 which is AIN21.
 c90:	95 e1       	ldi	r25, 0x15	; 21
 c92:	90 87       	std	Z+8, r25	; 0x08
	ADC0.MUXNEG = ADC_MUXNEG_GND_gc;					//Negative input to ground.
 c94:	90 e4       	ldi	r25, 0x40	; 64
 c96:	91 87       	std	Z+9, r25	; 0x09
	//ADC0.INTCTRL = ADC_WCMP_bm;						//Enable window comparator interrupt.
	ADC0.WINLT = ADC_LOW_VOLTAGE;						//Low threshold is 11V.
 c98:	24 e5       	ldi	r18, 0x54	; 84
 c9a:	39 e0       	ldi	r19, 0x09	; 9
 c9c:	22 8b       	std	Z+18, r18	; 0x12
 c9e:	33 8b       	std	Z+19, r19	; 0x13
	ADC0.DBGCTRL = ADC_DBGRUN_bm;						//Run while debuggin.
 ca0:	86 87       	std	Z+14, r24	; 0x0e
	ADC0.CTRLA |= ADC_ENABLE_bm;						//Enable ADC.
 ca2:	90 81       	ld	r25, Z
 ca4:	91 60       	ori	r25, 0x01	; 1
 ca6:	90 83       	st	Z, r25
	ADC0.COMMAND = ADC_STCONV_bm;						//Start converting.
 ca8:	82 87       	std	Z+10, r24	; 0x0a
 caa:	08 95       	ret

00000cac <systemADCResult>:
Returns: The most recent value in the ADC0.RES register.
Description: read returns.
*/
uint16_t systemADCResult()
{
	return ADC0.RES;
 cac:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <__RODATA_PM_OFFSET__+0x7f8610>
 cb0:	90 91 11 06 	lds	r25, 0x0611	; 0x800611 <__RODATA_PM_OFFSET__+0x7f8611>
}
 cb4:	08 95       	ret

00000cb6 <systemConfigTCB>:
Returns: none
Description: Sets up a TCB in periodic interrupt mode to a set interval, cmp.
*/

void systemConfigTCB(TCB_t *tcb, uint16_t cmp)
{
 cb6:	fc 01       	movw	r30, r24
	tcb->CTRLA = TCB_CLKSEL_TCA0_gc;					//Select TCA0 as clock source.
 cb8:	84 e0       	ldi	r24, 0x04	; 4
 cba:	80 83       	st	Z, r24
	tcb->CTRLB = TCB_CNTMODE_INT_gc;					//Periodic interrupt mode.
 cbc:	11 82       	std	Z+1, r1	; 0x01
	tcb->INTCTRL = TCB_CAPT_bm;							//Enable capture interrupt.
 cbe:	81 e0       	ldi	r24, 0x01	; 1
 cc0:	85 83       	std	Z+5, r24	; 0x05
	tcb->CCMP = cmp;									//Set compare value.
 cc2:	64 87       	std	Z+12, r22	; 0x0c
 cc4:	75 87       	std	Z+13, r23	; 0x0d
 cc6:	08 95       	ret

00000cc8 <systemEnableTCA0>:
*/

void systemEnableTCA0()
{
	/*TCA frequency = 23437 Hz = 24,000,000 Hz / 1,024*/
	TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1024_gc			//Will be using TCA0 as source for TCB0
 cc8:	e0 e0       	ldi	r30, 0x00	; 0
 cca:	fa e0       	ldi	r31, 0x0A	; 10
 ccc:	8f e0       	ldi	r24, 0x0F	; 15
 cce:	80 83       	st	Z, r24
					| TCA_SINGLE_ENABLE_bm;						//Enable TCA0.
	TCA0.SINGLE.DBGCTRL = 1;									//Run while debug.
 cd0:	81 e0       	ldi	r24, 0x01	; 1
 cd2:	86 87       	std	Z+14, r24	; 0x0e
	TCA0.SINGLE.PER = 0xFFFF;									//Max value for period.
 cd4:	8f ef       	ldi	r24, 0xFF	; 255
 cd6:	9f ef       	ldi	r25, 0xFF	; 255
 cd8:	86 a3       	std	Z+38, r24	; 0x26
 cda:	97 a3       	std	Z+39, r25	; 0x27
 cdc:	08 95       	ret

00000cde <systemEnableTCB>:
Returns: none
Description: enables a TCB timer.
*/

void systemEnableTCB(TCB_t *tcb)
{
 cde:	fc 01       	movw	r30, r24
	tcb->CTRLA |= TCB_ENABLE_bm;
 ce0:	90 81       	ld	r25, Z
 ce2:	91 60       	ori	r25, 0x01	; 1
 ce4:	90 83       	st	Z, r25
 ce6:	08 95       	ret

00000ce8 <systemDisableTCB>:
Returns: none
Description: Disables a TCB timer.
*/

void systemDisableTCB(TCB_t *tcb)
{
 ce8:	fc 01       	movw	r30, r24
	tcb->CTRLA &= ~(TCB_ENABLE_bm);
 cea:	90 81       	ld	r25, Z
 cec:	9e 7f       	andi	r25, 0xFE	; 254
 cee:	90 83       	st	Z, r25
 cf0:	08 95       	ret

00000cf2 <__udivmodhi4>:
 cf2:	aa 1b       	sub	r26, r26
 cf4:	bb 1b       	sub	r27, r27
 cf6:	51 e1       	ldi	r21, 0x11	; 17
 cf8:	07 c0       	rjmp	.+14     	; 0xd08 <__udivmodhi4_ep>

00000cfa <__udivmodhi4_loop>:
 cfa:	aa 1f       	adc	r26, r26
 cfc:	bb 1f       	adc	r27, r27
 cfe:	a6 17       	cp	r26, r22
 d00:	b7 07       	cpc	r27, r23
 d02:	10 f0       	brcs	.+4      	; 0xd08 <__udivmodhi4_ep>
 d04:	a6 1b       	sub	r26, r22
 d06:	b7 0b       	sbc	r27, r23

00000d08 <__udivmodhi4_ep>:
 d08:	88 1f       	adc	r24, r24
 d0a:	99 1f       	adc	r25, r25
 d0c:	5a 95       	dec	r21
 d0e:	a9 f7       	brne	.-22     	; 0xcfa <__udivmodhi4_loop>
 d10:	80 95       	com	r24
 d12:	90 95       	com	r25
 d14:	bc 01       	movw	r22, r24
 d16:	cd 01       	movw	r24, r26
 d18:	08 95       	ret

00000d1a <__divmodhi4>:
 d1a:	97 fb       	bst	r25, 7
 d1c:	07 2e       	mov	r0, r23
 d1e:	16 f4       	brtc	.+4      	; 0xd24 <__divmodhi4+0xa>
 d20:	00 94       	com	r0
 d22:	07 d0       	rcall	.+14     	; 0xd32 <__divmodhi4_neg1>
 d24:	77 fd       	sbrc	r23, 7
 d26:	09 d0       	rcall	.+18     	; 0xd3a <__divmodhi4_neg2>
 d28:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__udivmodhi4>
 d2c:	07 fc       	sbrc	r0, 7
 d2e:	05 d0       	rcall	.+10     	; 0xd3a <__divmodhi4_neg2>
 d30:	3e f4       	brtc	.+14     	; 0xd40 <__divmodhi4_exit>

00000d32 <__divmodhi4_neg1>:
 d32:	90 95       	com	r25
 d34:	81 95       	neg	r24
 d36:	9f 4f       	sbci	r25, 0xFF	; 255
 d38:	08 95       	ret

00000d3a <__divmodhi4_neg2>:
 d3a:	70 95       	com	r23
 d3c:	61 95       	neg	r22
 d3e:	7f 4f       	sbci	r23, 0xFF	; 255

00000d40 <__divmodhi4_exit>:
 d40:	08 95       	ret

00000d42 <__tablejump2__>:
 d42:	ee 0f       	add	r30, r30
 d44:	ff 1f       	adc	r31, r31
 d46:	05 90       	lpm	r0, Z+
 d48:	f4 91       	lpm	r31, Z
 d4a:	e0 2d       	mov	r30, r0
 d4c:	09 94       	ijmp

00000d4e <__umulhisi3>:
 d4e:	a2 9f       	mul	r26, r18
 d50:	b0 01       	movw	r22, r0
 d52:	b3 9f       	mul	r27, r19
 d54:	c0 01       	movw	r24, r0
 d56:	a3 9f       	mul	r26, r19
 d58:	70 0d       	add	r23, r0
 d5a:	81 1d       	adc	r24, r1
 d5c:	11 24       	eor	r1, r1
 d5e:	91 1d       	adc	r25, r1
 d60:	b2 9f       	mul	r27, r18
 d62:	70 0d       	add	r23, r0
 d64:	81 1d       	adc	r24, r1
 d66:	11 24       	eor	r1, r1
 d68:	91 1d       	adc	r25, r1
 d6a:	08 95       	ret

00000d6c <__cmpdi2_s8>:
 d6c:	00 24       	eor	r0, r0
 d6e:	a7 fd       	sbrc	r26, 7
 d70:	00 94       	com	r0
 d72:	2a 17       	cp	r18, r26
 d74:	30 05       	cpc	r19, r0
 d76:	40 05       	cpc	r20, r0
 d78:	50 05       	cpc	r21, r0
 d7a:	60 05       	cpc	r22, r0
 d7c:	70 05       	cpc	r23, r0
 d7e:	80 05       	cpc	r24, r0
 d80:	90 05       	cpc	r25, r0
 d82:	08 95       	ret

00000d84 <_exit>:
 d84:	f8 94       	cli

00000d86 <__stop_program>:
 d86:	ff cf       	rjmp	.-2      	; 0xd86 <__stop_program>
