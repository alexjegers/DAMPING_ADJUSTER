
DampingMotorControlExe001.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00807000  00000de8  00000e7c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000de8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000021  00807008  00807008  00000e84  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e84  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000eb4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002e8  00000000  00000000  00000ef0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005cb1  00000000  00000000  000011d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002c44  00000000  00000000  00006e89  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000015fc  00000000  00000000  00009acd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006e0  00000000  00000000  0000b0cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002795  00000000  00000000  0000b7ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000c3d  00000000  00000000  0000df41  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002a8  00000000  00000000  0000eb7e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
   4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
   8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
   c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  18:	0c 94 84 02 	jmp	0x508	; 0x508 <__vector_6>
  1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  30:	0c 94 07 03 	jmp	0x60e	; 0x60e <__vector_12>
  34:	0c 94 30 03 	jmp	0x660	; 0x660 <__vector_13>
  38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  7c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  80:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  84:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  88:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  8c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  90:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  94:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  98:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  9c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  a0:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  a4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  a8:	0c 94 be 02 	jmp	0x57c	; 0x57c <__vector_42>
  ac:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  b0:	a4 01       	movw	r20, r8
  b2:	7e 01       	movw	r14, r28
  b4:	81 01       	movw	r16, r2
  b6:	84 01       	movw	r16, r8
  b8:	87 01       	movw	r16, r14
  ba:	8a 01       	movw	r16, r20
  bc:	8d 01       	movw	r16, r26
  be:	90 01       	movw	r18, r0
  c0:	93 01       	movw	r18, r6

000000c2 <__ctors_end>:
  c2:	11 24       	eor	r1, r1
  c4:	1f be       	out	0x3f, r1	; 63
  c6:	cf ef       	ldi	r28, 0xFF	; 255
  c8:	cd bf       	out	0x3d, r28	; 61
  ca:	df e7       	ldi	r29, 0x7F	; 127
  cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
  ce:	10 e7       	ldi	r17, 0x70	; 112
  d0:	a0 e0       	ldi	r26, 0x00	; 0
  d2:	b0 e7       	ldi	r27, 0x70	; 112
  d4:	e8 ee       	ldi	r30, 0xE8	; 232
  d6:	fd e0       	ldi	r31, 0x0D	; 13
  d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
  da:	05 90       	lpm	r0, Z+
  dc:	0d 92       	st	X+, r0
  de:	a8 30       	cpi	r26, 0x08	; 8
  e0:	b1 07       	cpc	r27, r17
  e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
  e4:	20 e7       	ldi	r18, 0x70	; 112
  e6:	a8 e0       	ldi	r26, 0x08	; 8
  e8:	b0 e7       	ldi	r27, 0x70	; 112
  ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
  ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
  ee:	a9 32       	cpi	r26, 0x29	; 41
  f0:	b2 07       	cpc	r27, r18
  f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
  f4:	0e 94 57 03 	call	0x6ae	; 0x6ae <main>
  f8:	0c 94 f2 06 	jmp	0xde4	; 0xde4 <_exit>

000000fc <__bad_interrupt>:
  fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <encoderRotDirection>:
			interrupt.
*/

int8_t encoderRotDirection()
{
	if (ENC_A_LEVEL == ENC_B_LEVEL)
 100:	e0 e0       	ldi	r30, 0x00	; 0
 102:	f4 e0       	ldi	r31, 0x04	; 4
 104:	90 85       	ldd	r25, Z+8	; 0x08
 106:	81 e0       	ldi	r24, 0x01	; 1
 108:	89 27       	eor	r24, r25
 10a:	81 70       	andi	r24, 0x01	; 1
 10c:	90 85       	ldd	r25, Z+8	; 0x08
 10e:	96 95       	lsr	r25
 110:	91 70       	andi	r25, 0x01	; 1
 112:	89 17       	cp	r24, r25
 114:	11 f0       	breq	.+4      	; 0x11a <encoderRotDirection+0x1a>
	{
		return ROTATING_CW;
 116:	8b ef       	ldi	r24, 0xFB	; 251
 118:	08 95       	ret
	}
	else
	{
		return ROTATING_CCW;
 11a:	85 e0       	ldi	r24, 0x05	; 5
	}
 11c:	08 95       	ret

0000011e <iicInit>:
Returns: none
Description: Sets up the TWI hardware.
*/
void iicInit()
{
	pIIC->SCTRLA = (TWI_ENABLE_bm					//Slave enable.
 11e:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 122:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 126:	81 e4       	ldi	r24, 0x41	; 65
 128:	81 87       	std	Z+9, r24	; 0x09
				| TWI_APIEN_bm						//Address or stop interrupt enable.
				| TWI_DIEN_bp)						//Data interrupt enable.
				& ~(TWI_SMEN_bm						//Smart mode OFF.
				| TWI_PMEN_bm);						//Use address match logic.
				
	pIIC->SADDR = DEVICE_ADDR;						//Set the slave address.
 12a:	8a e0       	ldi	r24, 0x0A	; 10
 12c:	84 87       	std	Z+12, r24	; 0x0c
	pIIC->DBGCTRL = 1;								//Run while debuggin.
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	82 83       	std	Z+2, r24	; 0x02
	systemConfigTCB(iicTimeoutTimer, TCB_PER_1SEC);	//Configure the timeout timer to a 1 second timeout.
 132:	6d e8       	ldi	r22, 0x8D	; 141
 134:	7b e5       	ldi	r23, 0x5B	; 91
 136:	80 91 00 70 	lds	r24, 0x7000	; 0x807000 <__DATA_REGION_ORIGIN__>
 13a:	90 91 01 70 	lds	r25, 0x7001	; 0x807001 <__DATA_REGION_ORIGIN__+0x1>
 13e:	0e 94 8b 06 	call	0xd16	; 0xd16 <systemConfigTCB>
 142:	08 95       	ret

00000144 <iicAddrOrStopFlag>:
			NONE if neither APIF nor AP are set signifying the interrupt was caused
			by something else. 
*/
int8_t iicAddrOrStopFlag()
{
	if ((pIIC->SSTATUS & TWI_APIF_bm) == 0)
 144:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 148:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 14c:	83 85       	ldd	r24, Z+11	; 0x0b
 14e:	86 ff       	sbrs	r24, 6
 150:	05 c0       	rjmp	.+10     	; 0x15c <iicAddrOrStopFlag+0x18>
	{
		return NONE_FLAG;
	}
	else
	{
		if ((pIIC->SSTATUS & TWI_AP_bm) == 0)
 152:	83 85       	ldd	r24, Z+11	; 0x0b
 154:	80 fd       	sbrc	r24, 0
 156:	04 c0       	rjmp	.+8      	; 0x160 <iicAddrOrStopFlag+0x1c>
		{
			return STOP_FLAG;
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	08 95       	ret
*/
int8_t iicAddrOrStopFlag()
{
	if ((pIIC->SSTATUS & TWI_APIF_bm) == 0)
	{
		return NONE_FLAG;
 15c:	82 e0       	ldi	r24, 0x02	; 2
 15e:	08 95       	ret
	{
		if ((pIIC->SSTATUS & TWI_AP_bm) == 0)
		{
			return STOP_FLAG;
		}
		return ADDRESS_FLAG;
 160:	80 e0       	ldi	r24, 0x00	; 0
	}
}
 162:	08 95       	ret

00000164 <iicSendResponse>:
Description: Writes to TWI.SCTRLB register in response to data and address 
			interrupts. See data sheet for details on what the parameters do.
*/
void iicSendResponse(TWI_SCMD_t response, TWI_ACKACT_t ack)
{
	pIIC->SCTRLB = response | ack;
 164:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 168:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 16c:	86 2b       	or	r24, r22
 16e:	82 87       	std	Z+10, r24	; 0x0a
 170:	08 95       	ret

00000172 <iicReadOrWriteFlag>:
Description: Reads status register to see if the IIC master is requesting to read
			or write.
*/
int8_t iicReadOrWriteFlag()
{
	return pIIC->SSTATUS & TWI_DIR_bm;
 172:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 176:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 17a:	83 85       	ldd	r24, Z+11	; 0x0b
}
 17c:	82 70       	andi	r24, 0x02	; 2
 17e:	08 95       	ret

00000180 <iicDataIntFlag>:
Returns: State of the data interrupt flag.
Description: Returns zero if the flag is not set, non-zero if the flag is set.
*/
int8_t iicDataIntFlag()
{
	return pIIC->SSTATUS & TWI_DIF_bm;
 180:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 184:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 188:	83 85       	ldd	r24, Z+11	; 0x0b
}
 18a:	80 78       	andi	r24, 0x80	; 128
 18c:	08 95       	ret

0000018e <iicReadSdata>:
Returns: Data in TWI slave data (SDATA) register.
Description:
*/
char iicReadSdata()
{
	return pIIC->SDATA;
 18e:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 192:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 196:	85 85       	ldd	r24, Z+13	; 0x0d
}
 198:	08 95       	ret

0000019a <iicSetInternalAddress>:
Returns: none
Description: sets the internalAddress enum.
*/
void iicSetInternalAddress(INTERNAL_ADDRESS_t setInternalAddr)
{
	internalAddress = setInternalAddr;
 19a:	80 93 08 70 	sts	0x7008, r24	; 0x807008 <__data_end>
 19e:	08 95       	ret

000001a0 <iicWaitForDataIntFlag>:
Description: Sits in a while loop until the data interrupt flag is set.
*/

void iicWaitForDataIntFlag()
{
	systemEnableTCB(iicTimeoutTimer);
 1a0:	80 91 00 70 	lds	r24, 0x7000	; 0x807000 <__DATA_REGION_ORIGIN__>
 1a4:	90 91 01 70 	lds	r25, 0x7001	; 0x807001 <__DATA_REGION_ORIGIN__+0x1>
 1a8:	0e 94 9f 06 	call	0xd3e	; 0xd3e <systemEnableTCB>
	
	/*Wait for data*/
	while (iicDataIntFlag() == 0)
 1ac:	0b c0       	rjmp	.+22     	; 0x1c4 <iicWaitForDataIntFlag+0x24>
	{
		if (iicTimeoutTimer->INTFLAGS != 0)
 1ae:	e0 91 00 70 	lds	r30, 0x7000	; 0x807000 <__DATA_REGION_ORIGIN__>
 1b2:	f0 91 01 70 	lds	r31, 0x7001	; 0x807001 <__DATA_REGION_ORIGIN__+0x1>
 1b6:	86 81       	ldd	r24, Z+6	; 0x06
 1b8:	88 23       	and	r24, r24
 1ba:	21 f0       	breq	.+8      	; 0x1c4 <iicWaitForDataIntFlag+0x24>
		{
			iicSetInternalAddress(BASE_ADDRESS);
 1bc:	80 e0       	ldi	r24, 0x00	; 0
 1be:	0e 94 cd 00 	call	0x19a	; 0x19a <iicSetInternalAddress>
			break;
 1c2:	04 c0       	rjmp	.+8      	; 0x1cc <iicWaitForDataIntFlag+0x2c>
void iicWaitForDataIntFlag()
{
	systemEnableTCB(iicTimeoutTimer);
	
	/*Wait for data*/
	while (iicDataIntFlag() == 0)
 1c4:	0e 94 c0 00 	call	0x180	; 0x180 <iicDataIntFlag>
 1c8:	88 23       	and	r24, r24
 1ca:	89 f3       	breq	.-30     	; 0x1ae <iicWaitForDataIntFlag+0xe>
			iicSetInternalAddress(BASE_ADDRESS);
			break;
		}
	}

	systemDisableTCB(iicTimeoutTimer);
 1cc:	80 91 00 70 	lds	r24, 0x7000	; 0x807000 <__DATA_REGION_ORIGIN__>
 1d0:	90 91 01 70 	lds	r25, 0x7001	; 0x807001 <__DATA_REGION_ORIGIN__+0x1>
 1d4:	0e 94 a4 06 	call	0xd48	; 0xd48 <systemDisableTCB>
 1d8:	08 95       	ret

000001da <iicReadInternalAddress>:
Description:
*/
INTERNAL_ADDRESS_t iicReadInternalAddress(void)
{
	return internalAddress;
}
 1da:	80 91 08 70 	lds	r24, 0x7008	; 0x807008 <__data_end>
 1de:	08 95       	ret

000001e0 <iicWriteSdata>:
Description: writes data to the TWI slave data register (SDATA).
*/

void iicWriteSdata(uint8_t data)
{
	pIIC->SDATA = data;
 1e0:	e0 91 02 70 	lds	r30, 0x7002	; 0x807002 <pIIC>
 1e4:	f0 91 03 70 	lds	r31, 0x7003	; 0x807003 <pIIC+0x1>
 1e8:	85 87       	std	Z+13, r24	; 0x0d
 1ea:	08 95       	ret

000001ec <iicKill>:
Returns: none
Description: Disables slave mode.
*/
void iicKill()
{
	TWI1.CTRLA &= ~(TWI_ENABLE_bm);
 1ec:	e0 e2       	ldi	r30, 0x20	; 32
 1ee:	f9 e0       	ldi	r31, 0x09	; 9
 1f0:	80 81       	ld	r24, Z
 1f2:	8e 7f       	andi	r24, 0xFE	; 254
 1f4:	80 83       	st	Z, r24
 1f6:	08 95       	ret

000001f8 <iicWrite>:
Returns: none
Description: Used in response to a IIC Master read request. Puts data on the bus and handles
			the acks/nacks and completes the transaction.
*/
void iicWrite(void *dataAddr, uint8_t size)
{
 1f8:	0f 93       	push	r16
 1fa:	1f 93       	push	r17
 1fc:	cf 93       	push	r28
 1fe:	df 93       	push	r29
 200:	fc 01       	movw	r30, r24
 202:	d6 2f       	mov	r29, r22
	uint8_t *data = (uint8_t*)dataAddr;
	
	for (int8_t i = 0; i < size; i++)
 204:	c0 e0       	ldi	r28, 0x00	; 0
 206:	0e c0       	rjmp	.+28     	; 0x224 <__EEPROM_REGION_LENGTH__+0x24>
	{
		iicWriteSdata(*(data++));
 208:	8f 01       	movw	r16, r30
 20a:	0f 5f       	subi	r16, 0xFF	; 255
 20c:	1f 4f       	sbci	r17, 0xFF	; 255
 20e:	80 81       	ld	r24, Z
 210:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <iicWriteSdata>
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
 214:	60 e0       	ldi	r22, 0x00	; 0
 216:	83 e0       	ldi	r24, 0x03	; 3
 218:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
		iicWaitForDataIntFlag();
 21c:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <iicWaitForDataIntFlag>
*/
void iicWrite(void *dataAddr, uint8_t size)
{
	uint8_t *data = (uint8_t*)dataAddr;
	
	for (int8_t i = 0; i < size; i++)
 220:	cf 5f       	subi	r28, 0xFF	; 255
	{
		iicWriteSdata(*(data++));
 222:	f8 01       	movw	r30, r16
*/
void iicWrite(void *dataAddr, uint8_t size)
{
	uint8_t *data = (uint8_t*)dataAddr;
	
	for (int8_t i = 0; i < size; i++)
 224:	8d 2f       	mov	r24, r29
 226:	90 e0       	ldi	r25, 0x00	; 0
 228:	2c 2f       	mov	r18, r28
 22a:	0c 2e       	mov	r0, r28
 22c:	00 0c       	add	r0, r0
 22e:	33 0b       	sbc	r19, r19
 230:	28 17       	cp	r18, r24
 232:	39 07       	cpc	r19, r25
 234:	4c f3       	brlt	.-46     	; 0x208 <__EEPROM_REGION_LENGTH__+0x8>
		iicWriteSdata(*(data++));
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
		iicWaitForDataIntFlag();
	}
	
	iicSendResponse(TWI_SCMD_COMPTRANS_gc, TWI_ACKACT_ACK_gc);
 236:	60 e0       	ldi	r22, 0x00	; 0
 238:	82 e0       	ldi	r24, 0x02	; 2
 23a:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
}
 23e:	df 91       	pop	r29
 240:	cf 91       	pop	r28
 242:	1f 91       	pop	r17
 244:	0f 91       	pop	r16
 246:	08 95       	ret

00000248 <iicRead>:
Returns: uint64_t
Description: Used in response to an IIC Master write request. Reads in up to
			4 bytes of data and returns them as one whole 64 bit unsigned int.
*/
uint64_t iicRead(uint8_t size)
{
 248:	cf 92       	push	r12
 24a:	df 92       	push	r13
 24c:	ef 92       	push	r14
 24e:	ff 92       	push	r15
 250:	0f 93       	push	r16
 252:	1f 93       	push	r17
 254:	cf 93       	push	r28
 256:	df 93       	push	r29
 258:	cd b7       	in	r28, 0x3d	; 61
 25a:	de b7       	in	r29, 0x3e	; 62
 25c:	28 97       	sbiw	r28, 0x08	; 8
 25e:	cd bf       	out	0x3d, r28	; 61
 260:	de bf       	out	0x3e, r29	; 62
 262:	e8 2e       	mov	r14, r24
	uint64_t incomingData = 0;
 264:	19 82       	std	Y+1, r1	; 0x01
 266:	1a 82       	std	Y+2, r1	; 0x02
 268:	1b 82       	std	Y+3, r1	; 0x03
 26a:	1c 82       	std	Y+4, r1	; 0x04
 26c:	1d 82       	std	Y+5, r1	; 0x05
 26e:	1e 82       	std	Y+6, r1	; 0x06
 270:	1f 82       	std	Y+7, r1	; 0x07
 272:	18 86       	std	Y+8, r1	; 0x08
	uint8_t *pIncomingData = &incomingData;
	
	for (uint8_t i = 0; i < size - 1; i++)
 274:	f1 2c       	mov	r15, r1
			4 bytes of data and returns them as one whole 64 bit unsigned int.
*/
uint64_t iicRead(uint8_t size)
{
	uint64_t incomingData = 0;
	uint8_t *pIncomingData = &incomingData;
 276:	8e 01       	movw	r16, r28
 278:	0f 5f       	subi	r16, 0xFF	; 255
 27a:	1f 4f       	sbci	r17, 0xFF	; 255
	
	for (uint8_t i = 0; i < size - 1; i++)
 27c:	10 c0       	rjmp	.+32     	; 0x29e <iicRead+0x56>
	{
		*(pIncomingData++) = (uint8_t)iicReadSdata();
 27e:	68 01       	movw	r12, r16
 280:	8f ef       	ldi	r24, 0xFF	; 255
 282:	c8 1a       	sub	r12, r24
 284:	d8 0a       	sbc	r13, r24
 286:	0e 94 c7 00 	call	0x18e	; 0x18e <iicReadSdata>
 28a:	f8 01       	movw	r30, r16
 28c:	80 83       	st	Z, r24
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
 28e:	60 e0       	ldi	r22, 0x00	; 0
 290:	83 e0       	ldi	r24, 0x03	; 3
 292:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
		iicWaitForDataIntFlag();		
 296:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <iicWaitForDataIntFlag>
uint64_t iicRead(uint8_t size)
{
	uint64_t incomingData = 0;
	uint8_t *pIncomingData = &incomingData;
	
	for (uint8_t i = 0; i < size - 1; i++)
 29a:	f3 94       	inc	r15
	{
		*(pIncomingData++) = (uint8_t)iicReadSdata();
 29c:	86 01       	movw	r16, r12
uint64_t iicRead(uint8_t size)
{
	uint64_t incomingData = 0;
	uint8_t *pIncomingData = &incomingData;
	
	for (uint8_t i = 0; i < size - 1; i++)
 29e:	2f 2d       	mov	r18, r15
 2a0:	30 e0       	ldi	r19, 0x00	; 0
 2a2:	8e 2d       	mov	r24, r14
 2a4:	90 e0       	ldi	r25, 0x00	; 0
 2a6:	01 97       	sbiw	r24, 0x01	; 1
 2a8:	28 17       	cp	r18, r24
 2aa:	39 07       	cpc	r19, r25
 2ac:	44 f3       	brlt	.-48     	; 0x27e <iicRead+0x36>
	{
		*(pIncomingData++) = (uint8_t)iicReadSdata();
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
		iicWaitForDataIntFlag();		
	}
		*(pIncomingData++) = (uint8_t)iicReadSdata();
 2ae:	0e 94 c7 00 	call	0x18e	; 0x18e <iicReadSdata>
 2b2:	f8 01       	movw	r30, r16
 2b4:	80 83       	st	Z, r24
		iicSendResponse(TWI_SCMD_COMPTRANS_gc, TWI_ACKACT_NACK_gc);
 2b6:	64 e0       	ldi	r22, 0x04	; 4
 2b8:	82 e0       	ldi	r24, 0x02	; 2
 2ba:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
		iicWaitForDataIntFlag();	
 2be:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <iicWaitForDataIntFlag>
	return incomingData;
 2c2:	29 81       	ldd	r18, Y+1	; 0x01
 2c4:	3a 81       	ldd	r19, Y+2	; 0x02
 2c6:	4b 81       	ldd	r20, Y+3	; 0x03
 2c8:	5c 81       	ldd	r21, Y+4	; 0x04
 2ca:	6d 81       	ldd	r22, Y+5	; 0x05
 2cc:	7e 81       	ldd	r23, Y+6	; 0x06
 2ce:	8f 81       	ldd	r24, Y+7	; 0x07
 2d0:	98 85       	ldd	r25, Y+8	; 0x08
 2d2:	28 96       	adiw	r28, 0x08	; 8
 2d4:	cd bf       	out	0x3d, r28	; 61
 2d6:	de bf       	out	0x3e, r29	; 62
 2d8:	df 91       	pop	r29
 2da:	cf 91       	pop	r28
 2dc:	1f 91       	pop	r17
 2de:	0f 91       	pop	r16
 2e0:	ff 90       	pop	r15
 2e2:	ef 90       	pop	r14
 2e4:	df 90       	pop	r13
 2e6:	cf 90       	pop	r12
 2e8:	08 95       	ret

000002ea <iicHandleData>:
Description: Sends or receives requested data determined by internal address and
			iicReadOrWrite.
*/
void iicHandleData(INTERNAL_ADDRESS_t internalAddress)
{
	switch (internalAddress)
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	89 30       	cpi	r24, 0x09	; 9
 2ee:	91 05       	cpc	r25, r1
 2f0:	28 f5       	brcc	.+74     	; 0x33c <iicHandleData+0x52>
 2f2:	fc 01       	movw	r30, r24
 2f4:	e8 5a       	subi	r30, 0xA8	; 168
 2f6:	ff 4f       	sbci	r31, 0xFF	; 255
 2f8:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__tablejump2__>
	{
		case BASE_ADDRESS:
		break;
		
		case MOTOR_SET_POINT:
			handlerMotorSetPoint();			
 2fc:	0e 94 a8 01 	call	0x350	; 0x350 <handlerMotorSetPoint>
		break;
 300:	23 c0       	rjmp	.+70     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_POSITION:
			handlerMotorPosition();
 302:	0e 94 cb 01 	call	0x396	; 0x396 <handlerMotorPosition>
		break;
 306:	20 c0       	rjmp	.+64     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_SPEED:
			handlerMotorSpeed();
 308:	0e 94 ee 01 	call	0x3dc	; 0x3dc <handlerMotorSpeed>
		break;
 30c:	1d c0       	rjmp	.+58     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_CURRENT:
			handlerMotorCurrent();
 30e:	0e 94 11 02 	call	0x422	; 0x422 <handlerMotorCurrent>
		break;
 312:	1a c0       	rjmp	.+52     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_STEP_MODE:
			handlerMotorStepMode();
 314:	0e 94 32 02 	call	0x464	; 0x464 <handlerMotorStepMode>
		break;
 318:	17 c0       	rjmp	.+46     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_STATUS_FLAGS:
			handlerMotorStatusFlags();
 31a:	0e 94 4f 02 	call	0x49e	; 0x49e <handlerMotorStatusFlags>
		break;
 31e:	14 c0       	rjmp	.+40     	; 0x348 <iicHandleData+0x5e>
		
		case BATTERY_VOLTAGE:
			handlerBatteryVoltage();
 320:	0e 94 68 02 	call	0x4d0	; 0x4d0 <handlerBatteryVoltage>
		break;
 324:	11 c0       	rjmp	.+34     	; 0x348 <iicHandleData+0x5e>
		
		case MOTOR_GO_TO_ZERO:
			if (iicRead(1) == 0)
 326:	81 e0       	ldi	r24, 0x01	; 1
 328:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 32c:	a0 e0       	ldi	r26, 0x00	; 0
 32e:	0e 94 e6 06 	call	0xdcc	; 0xdcc <__cmpdi2_s8>
 332:	51 f4       	brne	.+20     	; 0x348 <iicHandleData+0x5e>
			{
				stepperSetFlag(FLAG_GO_TO_ZERO_bm);
 334:	88 e0       	ldi	r24, 0x08	; 8
 336:	0e 94 a9 05 	call	0xb52	; 0xb52 <stepperSetFlag>
 33a:	06 c0       	rjmp	.+12     	; 0x348 <iicHandleData+0x5e>
			}
		break;
		
		default:
			iicRead(1);										//Process the data in the register to keep the bus from hanging but don't do anything with it.
 33c:	81 e0       	ldi	r24, 0x01	; 1
 33e:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
			iicSetInternalAddress(BASE_ADDRESS);			//Reset to base address.
 342:	80 e0       	ldi	r24, 0x00	; 0
 344:	0e 94 cd 00 	call	0x19a	; 0x19a <iicSetInternalAddress>
		break;
	}		
	iicSetInternalAddress(BASE_ADDRESS);					//Reset to base address after handling data.
 348:	80 e0       	ldi	r24, 0x00	; 0
 34a:	0e 94 cd 00 	call	0x19a	; 0x19a <iicSetInternalAddress>
 34e:	08 95       	ret

00000350 <handlerMotorSetPoint>:

/*For detailed descriptions of the data and access of each address see 
"IIC Procedure" document in "DAMPING_ADJUSTER > Docs" folder.*/

void handlerMotorSetPoint()
{
 350:	cf 93       	push	r28
 352:	df 93       	push	r29
 354:	00 d0       	rcall	.+0      	; 0x356 <handlerMotorSetPoint+0x6>
 356:	cd b7       	in	r28, 0x3d	; 61
 358:	de b7       	in	r29, 0x3e	; 62
	uint16_t setPoint = 0;
 35a:	19 82       	std	Y+1, r1	; 0x01
 35c:	1a 82       	std	Y+2, r1	; 0x02
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 35e:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 362:	81 11       	cpse	r24, r1
 364:	0a c0       	rjmp	.+20     	; 0x37a <handlerMotorSetPoint+0x2a>
	{
		setPoint = iicRead(sizeof(setPoint));
 366:	82 e0       	ldi	r24, 0x02	; 2
 368:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 36c:	82 2f       	mov	r24, r18
 36e:	93 2f       	mov	r25, r19
 370:	29 83       	std	Y+1, r18	; 0x01
 372:	3a 83       	std	Y+2, r19	; 0x02
		stepperSetSetPoint(setPoint);
 374:	0e 94 08 05 	call	0xa10	; 0xa10 <stepperSetSetPoint>
 378:	09 c0       	rjmp	.+18     	; 0x38c <handlerMotorSetPoint+0x3c>
	}
	else
	{
		setPoint = stepperSetPoint();
 37a:	0e 94 56 05 	call	0xaac	; 0xaac <stepperSetPoint>
 37e:	89 83       	std	Y+1, r24	; 0x01
 380:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&setPoint, sizeof(setPoint));
 382:	62 e0       	ldi	r22, 0x02	; 2
 384:	ce 01       	movw	r24, r28
 386:	01 96       	adiw	r24, 0x01	; 1
 388:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 38c:	0f 90       	pop	r0
 38e:	0f 90       	pop	r0
 390:	df 91       	pop	r29
 392:	cf 91       	pop	r28
 394:	08 95       	ret

00000396 <handlerMotorPosition>:


void handlerMotorPosition()
{
 396:	cf 93       	push	r28
 398:	df 93       	push	r29
 39a:	00 d0       	rcall	.+0      	; 0x39c <handlerMotorPosition+0x6>
 39c:	cd b7       	in	r28, 0x3d	; 61
 39e:	de b7       	in	r29, 0x3e	; 62
	uint16_t position = 0;
 3a0:	19 82       	std	Y+1, r1	; 0x01
 3a2:	1a 82       	std	Y+2, r1	; 0x02
	
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 3a4:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 3a8:	81 11       	cpse	r24, r1
 3aa:	0a c0       	rjmp	.+20     	; 0x3c0 <handlerMotorPosition+0x2a>
	{
		position = iicRead(sizeof(position));
 3ac:	82 e0       	ldi	r24, 0x02	; 2
 3ae:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 3b2:	82 2f       	mov	r24, r18
 3b4:	93 2f       	mov	r25, r19
 3b6:	29 83       	std	Y+1, r18	; 0x01
 3b8:	3a 83       	std	Y+2, r19	; 0x02
		stepperSetPosition(position);
 3ba:	0e 94 22 05 	call	0xa44	; 0xa44 <stepperSetPosition>
 3be:	09 c0       	rjmp	.+18     	; 0x3d2 <handlerMotorPosition+0x3c>
	}
	else
	{
		position = stepperPosition();
 3c0:	0e 94 4f 05 	call	0xa9e	; 0xa9e <stepperPosition>
 3c4:	89 83       	std	Y+1, r24	; 0x01
 3c6:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&position, sizeof(position));
 3c8:	62 e0       	ldi	r22, 0x02	; 2
 3ca:	ce 01       	movw	r24, r28
 3cc:	01 96       	adiw	r24, 0x01	; 1
 3ce:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 3d2:	0f 90       	pop	r0
 3d4:	0f 90       	pop	r0
 3d6:	df 91       	pop	r29
 3d8:	cf 91       	pop	r28
 3da:	08 95       	ret

000003dc <handlerMotorSpeed>:


void handlerMotorSpeed()
{
 3dc:	cf 93       	push	r28
 3de:	df 93       	push	r29
 3e0:	00 d0       	rcall	.+0      	; 0x3e2 <handlerMotorSpeed+0x6>
 3e2:	cd b7       	in	r28, 0x3d	; 61
 3e4:	de b7       	in	r29, 0x3e	; 62
	uint16_t speed = 0;
 3e6:	19 82       	std	Y+1, r1	; 0x01
 3e8:	1a 82       	std	Y+2, r1	; 0x02
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 3ea:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 3ee:	81 11       	cpse	r24, r1
 3f0:	0a c0       	rjmp	.+20     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
	{
		speed = iicRead(sizeof(speed));
 3f2:	82 e0       	ldi	r24, 0x02	; 2
 3f4:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 3f8:	82 2f       	mov	r24, r18
 3fa:	93 2f       	mov	r25, r19
 3fc:	29 83       	std	Y+1, r18	; 0x01
 3fe:	3a 83       	std	Y+2, r19	; 0x02
		stepperSetSpeed(speed);
 400:	0e 94 85 04 	call	0x90a	; 0x90a <stepperSetSpeed>
 404:	09 c0       	rjmp	.+18     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
	}
	else
	{
		speed = stepperSpeed();
 406:	0e 94 5d 05 	call	0xaba	; 0xaba <stepperSpeed>
 40a:	89 83       	std	Y+1, r24	; 0x01
 40c:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&speed, sizeof(speed));
 40e:	62 e0       	ldi	r22, 0x02	; 2
 410:	ce 01       	movw	r24, r28
 412:	01 96       	adiw	r24, 0x01	; 1
 414:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}		
}
 418:	0f 90       	pop	r0
 41a:	0f 90       	pop	r0
 41c:	df 91       	pop	r29
 41e:	cf 91       	pop	r28
 420:	08 95       	ret

00000422 <handlerMotorCurrent>:


void handlerMotorCurrent()
{
 422:	cf 93       	push	r28
 424:	df 93       	push	r29
 426:	00 d0       	rcall	.+0      	; 0x428 <handlerMotorCurrent+0x6>
 428:	cd b7       	in	r28, 0x3d	; 61
 42a:	de b7       	in	r29, 0x3e	; 62
	CURRENT_LIMIT_t current;
	
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 42c:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 430:	81 11       	cpse	r24, r1
 432:	0a c0       	rjmp	.+20     	; 0x448 <handlerMotorCurrent+0x26>
	{
		current = iicRead(sizeof(current));
 434:	82 e0       	ldi	r24, 0x02	; 2
 436:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 43a:	82 2f       	mov	r24, r18
 43c:	93 2f       	mov	r25, r19
 43e:	29 83       	std	Y+1, r18	; 0x01
 440:	3a 83       	std	Y+2, r19	; 0x02
		stepperSetCurrent(current);
 442:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <stepperSetCurrent>
 446:	09 c0       	rjmp	.+18     	; 0x45a <handlerMotorCurrent+0x38>
	}
	else
	{
		current = stepperCurrentLimit();
 448:	0e 94 c0 05 	call	0xb80	; 0xb80 <stepperCurrentLimit>
 44c:	89 83       	std	Y+1, r24	; 0x01
 44e:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&current, sizeof(current));
 450:	62 e0       	ldi	r22, 0x02	; 2
 452:	ce 01       	movw	r24, r28
 454:	01 96       	adiw	r24, 0x01	; 1
 456:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 45a:	0f 90       	pop	r0
 45c:	0f 90       	pop	r0
 45e:	df 91       	pop	r29
 460:	cf 91       	pop	r28
 462:	08 95       	ret

00000464 <handlerMotorStepMode>:


void handlerMotorStepMode()
{
 464:	cf 93       	push	r28
 466:	df 93       	push	r29
 468:	1f 92       	push	r1
 46a:	cd b7       	in	r28, 0x3d	; 61
 46c:	de b7       	in	r29, 0x3e	; 62
	STEP_MODE_t stepMode;
	
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 46e:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 472:	81 11       	cpse	r24, r1
 474:	08 c0       	rjmp	.+16     	; 0x486 <handlerMotorStepMode+0x22>
	{
		stepMode = iicRead(sizeof(stepMode));
 476:	81 e0       	ldi	r24, 0x01	; 1
 478:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 47c:	82 2f       	mov	r24, r18
 47e:	29 83       	std	Y+1, r18	; 0x01
		stepperSetStepMode(stepMode);
 480:	0e 94 73 04 	call	0x8e6	; 0x8e6 <stepperSetStepMode>
 484:	08 c0       	rjmp	.+16     	; 0x496 <handlerMotorStepMode+0x32>
	}
	else
	{
		stepMode = stepperStepMode();
 486:	0e 94 c7 05 	call	0xb8e	; 0xb8e <stepperStepMode>
 48a:	89 83       	std	Y+1, r24	; 0x01
		iicWrite(&stepMode, sizeof(stepMode));
 48c:	61 e0       	ldi	r22, 0x01	; 1
 48e:	ce 01       	movw	r24, r28
 490:	01 96       	adiw	r24, 0x01	; 1
 492:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 496:	0f 90       	pop	r0
 498:	df 91       	pop	r29
 49a:	cf 91       	pop	r28
 49c:	08 95       	ret

0000049e <handlerMotorStatusFlags>:


void handlerMotorStatusFlags()
{
 49e:	cf 93       	push	r28
 4a0:	df 93       	push	r29
 4a2:	1f 92       	push	r1
 4a4:	cd b7       	in	r28, 0x3d	; 61
 4a6:	de b7       	in	r29, 0x3e	; 62
	uint8_t flags = 0;
 4a8:	19 82       	std	Y+1, r1	; 0x01
	
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 4aa:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 4ae:	81 11       	cpse	r24, r1
 4b0:	03 c0       	rjmp	.+6      	; 0x4b8 <handlerMotorStatusFlags+0x1a>
	{
		iicRead(0);									//Immediately NACK the data, this is a read only address.
 4b2:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 4b6:	08 c0       	rjmp	.+16     	; 0x4c8 <handlerMotorStatusFlags+0x2a>
	}
	else
	{
		flags = stepperFlags();
 4b8:	0e 94 ba 05 	call	0xb74	; 0xb74 <stepperFlags>
 4bc:	89 83       	std	Y+1, r24	; 0x01
		iicWrite(&flags, sizeof(flags));
 4be:	61 e0       	ldi	r22, 0x01	; 1
 4c0:	ce 01       	movw	r24, r28
 4c2:	01 96       	adiw	r24, 0x01	; 1
 4c4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
}
 4c8:	0f 90       	pop	r0
 4ca:	df 91       	pop	r29
 4cc:	cf 91       	pop	r28
 4ce:	08 95       	ret

000004d0 <handlerBatteryVoltage>:


void handlerBatteryVoltage()
{
 4d0:	cf 93       	push	r28
 4d2:	df 93       	push	r29
 4d4:	00 d0       	rcall	.+0      	; 0x4d6 <handlerBatteryVoltage+0x6>
 4d6:	cd b7       	in	r28, 0x3d	; 61
 4d8:	de b7       	in	r29, 0x3e	; 62
	uint16_t voltage = 0;
 4da:	19 82       	std	Y+1, r1	; 0x01
 4dc:	1a 82       	std	Y+2, r1	; 0x02
	if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)
 4de:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 4e2:	81 11       	cpse	r24, r1
 4e4:	03 c0       	rjmp	.+6      	; 0x4ec <handlerBatteryVoltage+0x1c>
	{
		iicRead(0);									//Immediately NACK the data, this is a read only address.
 4e6:	0e 94 24 01 	call	0x248	; 0x248 <iicRead>
 4ea:	09 c0       	rjmp	.+18     	; 0x4fe <handlerBatteryVoltage+0x2e>
	}
	else
	{
		voltage = systemADCResult();
 4ec:	0e 94 86 06 	call	0xd0c	; 0xd0c <systemADCResult>
 4f0:	89 83       	std	Y+1, r24	; 0x01
 4f2:	9a 83       	std	Y+2, r25	; 0x02
		iicWrite(&voltage, sizeof(voltage));
 4f4:	62 e0       	ldi	r22, 0x02	; 2
 4f6:	ce 01       	movw	r24, r28
 4f8:	01 96       	adiw	r24, 0x01	; 1
 4fa:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <iicWrite>
	}
 4fe:	0f 90       	pop	r0
 500:	0f 90       	pop	r0
 502:	df 91       	pop	r29
 504:	cf 91       	pop	r28
 506:	08 95       	ret

00000508 <__vector_6>:
#include "system.h"
#include "iic.h"

/*Port A interrupt for encoder*/
ISR(PORTA_PORT_vect)
{
 508:	1f 92       	push	r1
 50a:	0f 92       	push	r0
 50c:	0f b6       	in	r0, 0x3f	; 63
 50e:	0f 92       	push	r0
 510:	11 24       	eor	r1, r1
 512:	2f 93       	push	r18
 514:	3f 93       	push	r19
 516:	4f 93       	push	r20
 518:	5f 93       	push	r21
 51a:	6f 93       	push	r22
 51c:	7f 93       	push	r23
 51e:	8f 93       	push	r24
 520:	9f 93       	push	r25
 522:	af 93       	push	r26
 524:	bf 93       	push	r27
 526:	ef 93       	push	r30
 528:	ff 93       	push	r31
	if (stepperTimeoutCnt() > 850 || stepperTimeoutCnt() < 550)
 52a:	0e 94 d3 05 	call	0xba6	; 0xba6 <stepperTimeoutCnt>
 52e:	83 35       	cpi	r24, 0x53	; 83
 530:	93 40       	sbci	r25, 0x03	; 3
 532:	28 f4       	brcc	.+10     	; 0x53e <__vector_6+0x36>
 534:	0e 94 d3 05 	call	0xba6	; 0xba6 <stepperTimeoutCnt>
 538:	86 32       	cpi	r24, 0x26	; 38
 53a:	92 40       	sbci	r25, 0x02	; 2
 53c:	18 f4       	brcc	.+6      	; 0x544 <__vector_6+0x3c>
	{
		stepperIncrementTimeoutAmount();
 53e:	0e 94 a1 05 	call	0xb42	; 0xb42 <stepperIncrementTimeoutAmount>
 542:	02 c0       	rjmp	.+4      	; 0x548 <__vector_6+0x40>
	}
	else
	{
		stepperClearTimeoutAmount();
 544:	0e 94 9b 05 	call	0xb36	; 0xb36 <stepperClearTimeoutAmount>
	}
	stepperClearTimeoutCnt();
 548:	0e 94 da 05 	call	0xbb4	; 0xbb4 <stepperClearTimeoutCnt>
	
	int8_t direction = encoderRotDirection();					//Determine direction motor is rotating.
 54c:	0e 94 80 00 	call	0x100	; 0x100 <encoderRotDirection>
	stepperIncrementPosition(direction);						//Add/subtract from the current position.
 550:	0e 94 92 04 	call	0x924	; 0x924 <stepperIncrementPosition>
	PORTA.INTFLAGS = ENC_A_PIN;									//Clear interrupt flag.
 554:	81 e0       	ldi	r24, 0x01	; 1
 556:	80 93 09 04 	sts	0x0409, r24	; 0x800409 <__RODATA_PM_OFFSET__+0x7f8409>
}
 55a:	ff 91       	pop	r31
 55c:	ef 91       	pop	r30
 55e:	bf 91       	pop	r27
 560:	af 91       	pop	r26
 562:	9f 91       	pop	r25
 564:	8f 91       	pop	r24
 566:	7f 91       	pop	r23
 568:	6f 91       	pop	r22
 56a:	5f 91       	pop	r21
 56c:	4f 91       	pop	r20
 56e:	3f 91       	pop	r19
 570:	2f 91       	pop	r18
 572:	0f 90       	pop	r0
 574:	0f be       	out	0x3f, r0	; 63
 576:	0f 90       	pop	r0
 578:	1f 90       	pop	r1
 57a:	18 95       	reti

0000057c <__vector_42>:

/*IIC interrupt for incoming data*/
ISR(TWI1_TWIS_vect)
{
 57c:	1f 92       	push	r1
 57e:	0f 92       	push	r0
 580:	0f b6       	in	r0, 0x3f	; 63
 582:	0f 92       	push	r0
 584:	11 24       	eor	r1, r1
 586:	2f 93       	push	r18
 588:	3f 93       	push	r19
 58a:	4f 93       	push	r20
 58c:	5f 93       	push	r21
 58e:	6f 93       	push	r22
 590:	7f 93       	push	r23
 592:	8f 93       	push	r24
 594:	9f 93       	push	r25
 596:	af 93       	push	r26
 598:	bf 93       	push	r27
 59a:	ef 93       	push	r30
 59c:	ff 93       	push	r31
	if (iicReadInternalAddress() == BASE_ADDRESS)								//If it's starting for the first time.
 59e:	0e 94 ed 00 	call	0x1da	; 0x1da <iicReadInternalAddress>
 5a2:	81 11       	cpse	r24, r1
 5a4:	17 c0       	rjmp	.+46     	; 0x5d4 <__vector_42+0x58>
	{
		if (iicAddrOrStopFlag() == ADDRESS_FLAG)											//And it's not a stop.
 5a6:	0e 94 a2 00 	call	0x144	; 0x144 <iicAddrOrStopFlag>
 5aa:	81 11       	cpse	r24, r1
 5ac:	1f c0       	rjmp	.+62     	; 0x5ec <__vector_42+0x70>
		{
			if (iicReadOrWriteFlag() == IIC_REQUESTING_WRITE)						//And it's requesting to write means it going to be an internal address.
 5ae:	0e 94 b9 00 	call	0x172	; 0x172 <iicReadOrWriteFlag>
 5b2:	81 11       	cpse	r24, r1
 5b4:	1b c0       	rjmp	.+54     	; 0x5ec <__vector_42+0x70>
			{
				iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);		//Acknowledge
 5b6:	60 e0       	ldi	r22, 0x00	; 0
 5b8:	83 e0       	ldi	r24, 0x03	; 3
 5ba:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
				iicWaitForDataIntFlag();
 5be:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <iicWaitForDataIntFlag>
				iicSetInternalAddress((INTERNAL_ADDRESS_t)iicReadSdata());		//Save the internal address.
 5c2:	0e 94 c7 00 	call	0x18e	; 0x18e <iicReadSdata>
 5c6:	0e 94 cd 00 	call	0x19a	; 0x19a <iicSetInternalAddress>
				iicSendResponse(TWI_SCMD_COMPTRANS_gc, TWI_ACKACT_NACK_gc);		//Acknowledge
 5ca:	64 e0       	ldi	r22, 0x04	; 4
 5cc:	82 e0       	ldi	r24, 0x02	; 2
 5ce:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
 5d2:	0c c0       	rjmp	.+24     	; 0x5ec <__vector_42+0x70>
			}
		}
	}
	else //Not the BASE_ADDRESS means the internal address is already written.
	{
		iicSendResponse(TWI_SCMD_RESPONSE_gc, TWI_ACKACT_ACK_gc);
 5d4:	60 e0       	ldi	r22, 0x00	; 0
 5d6:	83 e0       	ldi	r24, 0x03	; 3
 5d8:	0e 94 b2 00 	call	0x164	; 0x164 <iicSendResponse>
		while (iicDataIntFlag() == 0) {}		
 5dc:	0e 94 c0 00 	call	0x180	; 0x180 <iicDataIntFlag>
 5e0:	88 23       	and	r24, r24
 5e2:	e1 f3       	breq	.-8      	; 0x5dc <__vector_42+0x60>
		iicHandleData(iicReadInternalAddress());
 5e4:	0e 94 ed 00 	call	0x1da	; 0x1da <iicReadInternalAddress>
 5e8:	0e 94 75 01 	call	0x2ea	; 0x2ea <iicHandleData>
	}
	
}
 5ec:	ff 91       	pop	r31
 5ee:	ef 91       	pop	r30
 5f0:	bf 91       	pop	r27
 5f2:	af 91       	pop	r26
 5f4:	9f 91       	pop	r25
 5f6:	8f 91       	pop	r24
 5f8:	7f 91       	pop	r23
 5fa:	6f 91       	pop	r22
 5fc:	5f 91       	pop	r21
 5fe:	4f 91       	pop	r20
 600:	3f 91       	pop	r19
 602:	2f 91       	pop	r18
 604:	0f 90       	pop	r0
 606:	0f be       	out	0x3f, r0	; 63
 608:	0f 90       	pop	r0
 60a:	1f 90       	pop	r1
 60c:	18 95       	reti

0000060e <__vector_12>:


/*IIC timeout interrupt.*/
ISR(TCB0_INT_vect)
{
 60e:	1f 92       	push	r1
 610:	0f 92       	push	r0
 612:	0f b6       	in	r0, 0x3f	; 63
 614:	0f 92       	push	r0
 616:	11 24       	eor	r1, r1
 618:	2f 93       	push	r18
 61a:	3f 93       	push	r19
 61c:	4f 93       	push	r20
 61e:	5f 93       	push	r21
 620:	6f 93       	push	r22
 622:	7f 93       	push	r23
 624:	8f 93       	push	r24
 626:	9f 93       	push	r25
 628:	af 93       	push	r26
 62a:	bf 93       	push	r27
 62c:	ef 93       	push	r30
 62e:	ff 93       	push	r31
	iicKill();							//Disable IIC slave.
 630:	0e 94 f6 00 	call	0x1ec	; 0x1ec <iicKill>
	iicInit();							//Enable IIC slave.
 634:	0e 94 8f 00 	call	0x11e	; 0x11e <iicInit>
	TCB0.INTFLAGS = TCB_CAPT_bm;		//Clear interrupt flag.
 638:	81 e0       	ldi	r24, 0x01	; 1
 63a:	80 93 06 0b 	sts	0x0B06, r24	; 0x800b06 <__RODATA_PM_OFFSET__+0x7f8b06>
}
 63e:	ff 91       	pop	r31
 640:	ef 91       	pop	r30
 642:	bf 91       	pop	r27
 644:	af 91       	pop	r26
 646:	9f 91       	pop	r25
 648:	8f 91       	pop	r24
 64a:	7f 91       	pop	r23
 64c:	6f 91       	pop	r22
 64e:	5f 91       	pop	r21
 650:	4f 91       	pop	r20
 652:	3f 91       	pop	r19
 654:	2f 91       	pop	r18
 656:	0f 90       	pop	r0
 658:	0f be       	out	0x3f, r0	; 63
 65a:	0f 90       	pop	r0
 65c:	1f 90       	pop	r1
 65e:	18 95       	reti

00000660 <__vector_13>:

/*Stepper timeout interrupt.*/
ISR(TCB1_INT_vect)
{
 660:	1f 92       	push	r1
 662:	0f 92       	push	r0
 664:	0f b6       	in	r0, 0x3f	; 63
 666:	0f 92       	push	r0
 668:	11 24       	eor	r1, r1
 66a:	2f 93       	push	r18
 66c:	3f 93       	push	r19
 66e:	4f 93       	push	r20
 670:	5f 93       	push	r21
 672:	6f 93       	push	r22
 674:	7f 93       	push	r23
 676:	8f 93       	push	r24
 678:	9f 93       	push	r25
 67a:	af 93       	push	r26
 67c:	bf 93       	push	r27
 67e:	ef 93       	push	r30
 680:	ff 93       	push	r31
	stepperIncrementTimeoutAmount();	//Increment timeout counter.
 682:	0e 94 a1 05 	call	0xb42	; 0xb42 <stepperIncrementTimeoutAmount>
	TCB1.INTFLAGS = TCB_CAPT_bm;		//Clear the interrupt flag.
 686:	81 e0       	ldi	r24, 0x01	; 1
 688:	80 93 16 0b 	sts	0x0B16, r24	; 0x800b16 <__RODATA_PM_OFFSET__+0x7f8b16>
 68c:	ff 91       	pop	r31
 68e:	ef 91       	pop	r30
 690:	bf 91       	pop	r27
 692:	af 91       	pop	r26
 694:	9f 91       	pop	r25
 696:	8f 91       	pop	r24
 698:	7f 91       	pop	r23
 69a:	6f 91       	pop	r22
 69c:	5f 91       	pop	r21
 69e:	4f 91       	pop	r20
 6a0:	3f 91       	pop	r19
 6a2:	2f 91       	pop	r18
 6a4:	0f 90       	pop	r0
 6a6:	0f be       	out	0x3f, r0	; 63
 6a8:	0f 90       	pop	r0
 6aa:	1f 90       	pop	r1
 6ac:	18 95       	reti

000006ae <main>:


int main(void)
{	
	/*Enable global interrupts*/
	sei();											
 6ae:	78 94       	sei

	/*Configure system clock*/
	systemClockConfig();
 6b0:	0e 94 5e 06 	call	0xcbc	; 0xcbc <systemClockConfig>
	
	/*Configure pins in each port*/
	systemPortAConfig();
 6b4:	0e 94 1c 06 	call	0xc38	; 0xc38 <systemPortAConfig>
	systemPortCConfig();
 6b8:	0e 94 35 06 	call	0xc6a	; 0xc6a <systemPortCConfig>
	systemPortDConfig();
 6bc:	0e 94 47 06 	call	0xc8e	; 0xc8e <systemPortDConfig>
	systemPortFConfig();
 6c0:	0e 94 56 06 	call	0xcac	; 0xcac <systemPortFConfig>
	
	/*Enable TCA0 which is used as a source for TCBx*/
	systemEnableTCA0();
 6c4:	0e 94 94 06 	call	0xd28	; 0xd28 <systemEnableTCA0>

	/*Configure ADC to read car battery/stepper supply voltage*/
	systemConfigADC();
 6c8:	0e 94 67 06 	call	0xcce	; 0xcce <systemConfigADC>
	
	/*Load default stepper settings*/
	stepperInit();
 6cc:	0e 94 6c 05 	call	0xad8	; 0xad8 <stepperInit>
		
	/*Wait until the correct position is written from the master or go to zero flag is set.*/
	while ((stepperPosition() == -1) || (stepperSetPoint() == -1)) 
 6d0:	05 c0       	rjmp	.+10     	; 0x6dc <main+0x2e>
	{
		/*If the goToZero flag is set, run stepperGoToZero.*/
		if ((stepperFlags() & FLAG_GO_TO_ZERO_bm) != 0)
 6d2:	0e 94 ba 05 	call	0xb74	; 0xb74 <stepperFlags>
 6d6:	83 fd       	sbrc	r24, 3
		{
			stepperGoToZero();
 6d8:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <stepperGoToZero>
	
	/*Load default stepper settings*/
	stepperInit();
		
	/*Wait until the correct position is written from the master or go to zero flag is set.*/
	while ((stepperPosition() == -1) || (stepperSetPoint() == -1)) 
 6dc:	0e 94 4f 05 	call	0xa9e	; 0xa9e <stepperPosition>
 6e0:	01 96       	adiw	r24, 0x01	; 1
 6e2:	b9 f3       	breq	.-18     	; 0x6d2 <main+0x24>
 6e4:	0e 94 56 05 	call	0xaac	; 0xaac <stepperSetPoint>
 6e8:	01 96       	adiw	r24, 0x01	; 1
 6ea:	99 f3       	breq	.-26     	; 0x6d2 <main+0x24>
 6ec:	29 c0       	rjmp	.+82     	; 0x740 <main+0x92>
    {
		/*While the stepper position is not equal to the set point...*/
		while ((stepperAtSetPoint() == 0))					
		{
			/*If the stepper isn't already moving, start the timeout timer*/
			if (stepperIsMoving() == false)				
 6ee:	0e 94 15 06 	call	0xc2a	; 0xc2a <stepperIsMoving>
 6f2:	81 11       	cpse	r24, r1
 6f4:	06 c0       	rjmp	.+12     	; 0x702 <main+0x54>
			{
				stepperClearTimeoutAmount();						//Clear the current timeout amount.
 6f6:	0e 94 9b 05 	call	0xb36	; 0xb36 <stepperClearTimeoutAmount>
				stepperClearTimeoutCnt();							//Clear the actual timer count register.
 6fa:	0e 94 da 05 	call	0xbb4	; 0xbb4 <stepperClearTimeoutCnt>
				stepperStartTimeoutTimer();							//Start the timer.
 6fe:	0e 94 94 05 	call	0xb28	; 0xb28 <stepperStartTimeoutTimer>
			}
			
			/*If the stepper timesout more than 10 times in a row while moving, assume
				that it is stuck, change the set point to the position that it's stuck
				on, and stop trying to move it.*/
			if (stepperTimeoutAmount() > 10)
 702:	0e 94 cd 05 	call	0xb9a	; 0xb9a <stepperTimeoutAmount>
 706:	8b 30       	cpi	r24, 0x0B	; 11
 708:	28 f0       	brcs	.+10     	; 0x714 <main+0x66>
			{
				stepperSetSetPoint(stepperPosition());
 70a:	0e 94 4f 05 	call	0xa9e	; 0xa9e <stepperPosition>
 70e:	0e 94 08 05 	call	0xa10	; 0xa10 <stepperSetSetPoint>
				break;
 712:	1a c0       	rjmp	.+52     	; 0x748 <main+0x9a>
			}
			
			/*Determine direction of rotation.*/
			if (stepperPosition() < stepperSetPoint())
 714:	0e 94 4f 05 	call	0xa9e	; 0xa9e <stepperPosition>
 718:	ec 01       	movw	r28, r24
 71a:	0e 94 56 05 	call	0xaac	; 0xaac <stepperSetPoint>
 71e:	c8 17       	cp	r28, r24
 720:	d9 07       	cpc	r29, r25
 722:	24 f4       	brge	.+8      	; 0x72c <main+0x7e>
			{
				stepperSetDirection(DIRECTION_CW);
 724:	8f ef       	ldi	r24, 0xFF	; 255
 726:	0e 94 c6 04 	call	0x98c	; 0x98c <stepperSetDirection>
 72a:	03 c0       	rjmp	.+6      	; 0x732 <main+0x84>
			} 
			else
			{
				stepperSetDirection(DIRECTION_CCW);
 72c:	81 e0       	ldi	r24, 0x01	; 1
 72e:	0e 94 c6 04 	call	0x98c	; 0x98c <stepperSetDirection>
			}
			
			/*Start moving*/
			stepperStartMove();
 732:	0e 94 b4 03 	call	0x768	; 0x768 <stepperStartMove>
			STEPPER_ENABLE;
 736:	e0 e4       	ldi	r30, 0x40	; 64
 738:	f4 e0       	ldi	r31, 0x04	; 4
 73a:	84 81       	ldd	r24, Z+4	; 0x04
 73c:	8b 7f       	andi	r24, 0xFB	; 251
 73e:	84 83       	std	Z+4, r24	; 0x04
	}
	
    while (1) 
    {
		/*While the stepper position is not equal to the set point...*/
		while ((stepperAtSetPoint() == 0))					
 740:	0e 94 40 05 	call	0xa80	; 0xa80 <stepperAtSetPoint>
 744:	88 23       	and	r24, r24
 746:	99 f2       	breq	.-90     	; 0x6ee <main+0x40>
			stepperStartMove();
			STEPPER_ENABLE;
		}
		
		/*When the stepper position is equal to the set point*/
		STEPPER_DISABLE;
 748:	e0 e4       	ldi	r30, 0x40	; 64
 74a:	f4 e0       	ldi	r31, 0x04	; 4
 74c:	84 81       	ldd	r24, Z+4	; 0x04
 74e:	84 60       	ori	r24, 0x04	; 4
 750:	84 83       	std	Z+4, r24	; 0x04
		stepperStopMove();
 752:	0e 94 8c 04 	call	0x918	; 0x918 <stepperStopMove>
		stepperStopTimeoutTimer();
 756:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <stepperStopTimeoutTimer>
		
		/*If the go to zero flag is set run the go to zero function.*/
		if ((stepperFlags() & FLAG_GO_TO_ZERO_bm) != 0)
 75a:	0e 94 ba 05 	call	0xb74	; 0xb74 <stepperFlags>
 75e:	83 ff       	sbrs	r24, 3
 760:	ef cf       	rjmp	.-34     	; 0x740 <main+0x92>
		{
			stepperGoToZero();
 762:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <stepperGoToZero>
 766:	ec cf       	rjmp	.-40     	; 0x740 <main+0x92>

00000768 <stepperStartMove>:
Description: ... used to determine if it is spinning the correct direction.
*/
int16_t stepperPreviousPosition()
{
	return pMotor->previousPosition;
}
 768:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 76c:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 770:	86 81       	ldd	r24, Z+6	; 0x06
 772:	82 30       	cpi	r24, 0x02	; 2
 774:	f1 f1       	breq	.+124    	; 0x7f2 <stepperStartMove+0x8a>
 776:	2c f4       	brge	.+10     	; 0x782 <stepperStartMove+0x1a>
 778:	88 23       	and	r24, r24
 77a:	61 f0       	breq	.+24     	; 0x794 <stepperStartMove+0x2c>
 77c:	81 30       	cpi	r24, 0x01	; 1
 77e:	01 f1       	breq	.+64     	; 0x7c0 <stepperStartMove+0x58>
 780:	9c c0       	rjmp	.+312    	; 0x8ba <stepperStartMove+0x152>
 782:	84 30       	cpi	r24, 0x04	; 4
 784:	09 f4       	brne	.+2      	; 0x788 <stepperStartMove+0x20>
 786:	67 c0       	rjmp	.+206    	; 0x856 <stepperStartMove+0xee>
 788:	0c f4       	brge	.+2      	; 0x78c <stepperStartMove+0x24>
 78a:	4c c0       	rjmp	.+152    	; 0x824 <stepperStartMove+0xbc>
 78c:	85 30       	cpi	r24, 0x05	; 5
 78e:	09 f4       	brne	.+2      	; 0x792 <stepperStartMove+0x2a>
 790:	7b c0       	rjmp	.+246    	; 0x888 <stepperStartMove+0x120>
 792:	93 c0       	rjmp	.+294    	; 0x8ba <stepperStartMove+0x152>
 794:	82 85       	ldd	r24, Z+10	; 0x0a
 796:	93 85       	ldd	r25, Z+11	; 0x0b
 798:	48 ec       	ldi	r20, 0xC8	; 200
 79a:	48 9f       	mul	r20, r24
 79c:	90 01       	movw	r18, r0
 79e:	49 9f       	mul	r20, r25
 7a0:	30 0d       	add	r19, r0
 7a2:	11 24       	eor	r1, r1
 7a4:	a9 e8       	ldi	r26, 0x89	; 137
 7a6:	b8 e8       	ldi	r27, 0x88	; 136
 7a8:	0e 94 d7 06 	call	0xdae	; 0xdae <__umulhisi3>
 7ac:	bc 01       	movw	r22, r24
 7ae:	76 95       	lsr	r23
 7b0:	67 95       	ror	r22
 7b2:	72 95       	swap	r23
 7b4:	62 95       	swap	r22
 7b6:	6f 70       	andi	r22, 0x0F	; 15
 7b8:	67 27       	eor	r22, r23
 7ba:	7f 70       	andi	r23, 0x0F	; 15
 7bc:	67 27       	eor	r22, r23
 7be:	7f c0       	rjmp	.+254    	; 0x8be <stepperStartMove+0x156>
 7c0:	42 85       	ldd	r20, Z+10	; 0x0a
 7c2:	53 85       	ldd	r21, Z+11	; 0x0b
 7c4:	80 e9       	ldi	r24, 0x90	; 144
 7c6:	91 e0       	ldi	r25, 0x01	; 1
 7c8:	48 9f       	mul	r20, r24
 7ca:	90 01       	movw	r18, r0
 7cc:	49 9f       	mul	r20, r25
 7ce:	30 0d       	add	r19, r0
 7d0:	58 9f       	mul	r21, r24
 7d2:	30 0d       	add	r19, r0
 7d4:	11 24       	eor	r1, r1
 7d6:	a9 e8       	ldi	r26, 0x89	; 137
 7d8:	b8 e8       	ldi	r27, 0x88	; 136
 7da:	0e 94 d7 06 	call	0xdae	; 0xdae <__umulhisi3>
 7de:	bc 01       	movw	r22, r24
 7e0:	76 95       	lsr	r23
 7e2:	67 95       	ror	r22
 7e4:	72 95       	swap	r23
 7e6:	62 95       	swap	r22
 7e8:	6f 70       	andi	r22, 0x0F	; 15
 7ea:	67 27       	eor	r22, r23
 7ec:	7f 70       	andi	r23, 0x0F	; 15
 7ee:	67 27       	eor	r22, r23
 7f0:	66 c0       	rjmp	.+204    	; 0x8be <stepperStartMove+0x156>
 7f2:	42 85       	ldd	r20, Z+10	; 0x0a
 7f4:	53 85       	ldd	r21, Z+11	; 0x0b
 7f6:	80 e2       	ldi	r24, 0x20	; 32
 7f8:	93 e0       	ldi	r25, 0x03	; 3
 7fa:	48 9f       	mul	r20, r24
 7fc:	90 01       	movw	r18, r0
 7fe:	49 9f       	mul	r20, r25
 800:	30 0d       	add	r19, r0
 802:	58 9f       	mul	r21, r24
 804:	30 0d       	add	r19, r0
 806:	11 24       	eor	r1, r1
 808:	a9 e8       	ldi	r26, 0x89	; 137
 80a:	b8 e8       	ldi	r27, 0x88	; 136
 80c:	0e 94 d7 06 	call	0xdae	; 0xdae <__umulhisi3>
 810:	bc 01       	movw	r22, r24
 812:	76 95       	lsr	r23
 814:	67 95       	ror	r22
 816:	72 95       	swap	r23
 818:	62 95       	swap	r22
 81a:	6f 70       	andi	r22, 0x0F	; 15
 81c:	67 27       	eor	r22, r23
 81e:	7f 70       	andi	r23, 0x0F	; 15
 820:	67 27       	eor	r22, r23
 822:	4d c0       	rjmp	.+154    	; 0x8be <stepperStartMove+0x156>
 824:	42 85       	ldd	r20, Z+10	; 0x0a
 826:	53 85       	ldd	r21, Z+11	; 0x0b
 828:	80 e4       	ldi	r24, 0x40	; 64
 82a:	96 e0       	ldi	r25, 0x06	; 6
 82c:	48 9f       	mul	r20, r24
 82e:	90 01       	movw	r18, r0
 830:	49 9f       	mul	r20, r25
 832:	30 0d       	add	r19, r0
 834:	58 9f       	mul	r21, r24
 836:	30 0d       	add	r19, r0
 838:	11 24       	eor	r1, r1
 83a:	a9 e8       	ldi	r26, 0x89	; 137
 83c:	b8 e8       	ldi	r27, 0x88	; 136
 83e:	0e 94 d7 06 	call	0xdae	; 0xdae <__umulhisi3>
 842:	bc 01       	movw	r22, r24
 844:	76 95       	lsr	r23
 846:	67 95       	ror	r22
 848:	72 95       	swap	r23
 84a:	62 95       	swap	r22
 84c:	6f 70       	andi	r22, 0x0F	; 15
 84e:	67 27       	eor	r22, r23
 850:	7f 70       	andi	r23, 0x0F	; 15
 852:	67 27       	eor	r22, r23
 854:	34 c0       	rjmp	.+104    	; 0x8be <stepperStartMove+0x156>
 856:	42 85       	ldd	r20, Z+10	; 0x0a
 858:	53 85       	ldd	r21, Z+11	; 0x0b
 85a:	80 e8       	ldi	r24, 0x80	; 128
 85c:	9c e0       	ldi	r25, 0x0C	; 12
 85e:	48 9f       	mul	r20, r24
 860:	90 01       	movw	r18, r0
 862:	49 9f       	mul	r20, r25
 864:	30 0d       	add	r19, r0
 866:	58 9f       	mul	r21, r24
 868:	30 0d       	add	r19, r0
 86a:	11 24       	eor	r1, r1
 86c:	a9 e8       	ldi	r26, 0x89	; 137
 86e:	b8 e8       	ldi	r27, 0x88	; 136
 870:	0e 94 d7 06 	call	0xdae	; 0xdae <__umulhisi3>
 874:	bc 01       	movw	r22, r24
 876:	76 95       	lsr	r23
 878:	67 95       	ror	r22
 87a:	72 95       	swap	r23
 87c:	62 95       	swap	r22
 87e:	6f 70       	andi	r22, 0x0F	; 15
 880:	67 27       	eor	r22, r23
 882:	7f 70       	andi	r23, 0x0F	; 15
 884:	67 27       	eor	r22, r23
 886:	1b c0       	rjmp	.+54     	; 0x8be <stepperStartMove+0x156>
 888:	42 85       	ldd	r20, Z+10	; 0x0a
 88a:	53 85       	ldd	r21, Z+11	; 0x0b
 88c:	80 e0       	ldi	r24, 0x00	; 0
 88e:	99 e1       	ldi	r25, 0x19	; 25
 890:	48 9f       	mul	r20, r24
 892:	90 01       	movw	r18, r0
 894:	49 9f       	mul	r20, r25
 896:	30 0d       	add	r19, r0
 898:	58 9f       	mul	r21, r24
 89a:	30 0d       	add	r19, r0
 89c:	11 24       	eor	r1, r1
 89e:	a9 e8       	ldi	r26, 0x89	; 137
 8a0:	b8 e8       	ldi	r27, 0x88	; 136
 8a2:	0e 94 d7 06 	call	0xdae	; 0xdae <__umulhisi3>
 8a6:	bc 01       	movw	r22, r24
 8a8:	76 95       	lsr	r23
 8aa:	67 95       	ror	r22
 8ac:	72 95       	swap	r23
 8ae:	62 95       	swap	r22
 8b0:	6f 70       	andi	r22, 0x0F	; 15
 8b2:	67 27       	eor	r22, r23
 8b4:	7f 70       	andi	r23, 0x0F	; 15
 8b6:	67 27       	eor	r22, r23
 8b8:	02 c0       	rjmp	.+4      	; 0x8be <stepperStartMove+0x156>
 8ba:	60 e0       	ldi	r22, 0x00	; 0
 8bc:	70 e0       	ldi	r23, 0x00	; 0
 8be:	61 15       	cp	r22, r1
 8c0:	71 05       	cpc	r23, r1
 8c2:	21 f4       	brne	.+8      	; 0x8cc <stepperStartMove+0x164>
 8c4:	85 85       	ldd	r24, Z+13	; 0x0d
 8c6:	84 60       	ori	r24, 0x04	; 4
 8c8:	85 87       	std	Z+13, r24	; 0x0d
 8ca:	08 95       	ret
 8cc:	8d e8       	ldi	r24, 0x8D	; 141
 8ce:	9b e5       	ldi	r25, 0x5B	; 91
 8d0:	0e 94 a9 06 	call	0xd52	; 0xd52 <__udivmodhi4>
 8d4:	e0 e2       	ldi	r30, 0x20	; 32
 8d6:	fb e0       	ldi	r31, 0x0B	; 11
 8d8:	64 87       	std	Z+12, r22	; 0x0c
 8da:	66 95       	lsr	r22
 8dc:	65 87       	std	Z+13, r22	; 0x0d
 8de:	80 81       	ld	r24, Z
 8e0:	81 60       	ori	r24, 0x01	; 1
 8e2:	80 83       	st	Z, r24
 8e4:	08 95       	ret

000008e6 <stepperSetStepMode>:
 8e6:	a0 91 06 70 	lds	r26, 0x7006	; 0x807006 <pMotor>
 8ea:	b0 91 07 70 	lds	r27, 0x7007	; 0x807007 <pMotor+0x1>
 8ee:	16 96       	adiw	r26, 0x06	; 6
 8f0:	8c 93       	st	X, r24
 8f2:	16 97       	sbiw	r26, 0x06	; 6
 8f4:	e0 e6       	ldi	r30, 0x60	; 96
 8f6:	f4 e0       	ldi	r31, 0x04	; 4
 8f8:	84 81       	ldd	r24, Z+4	; 0x04
 8fa:	88 7f       	andi	r24, 0xF8	; 248
 8fc:	84 83       	std	Z+4, r24	; 0x04
 8fe:	94 81       	ldd	r25, Z+4	; 0x04
 900:	16 96       	adiw	r26, 0x06	; 6
 902:	8c 91       	ld	r24, X
 904:	89 2b       	or	r24, r25
 906:	84 83       	std	Z+4, r24	; 0x04
 908:	08 95       	ret

0000090a <stepperSetSpeed>:
 90a:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 90e:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 912:	82 87       	std	Z+10, r24	; 0x0a
 914:	93 87       	std	Z+11, r25	; 0x0b
 916:	08 95       	ret

00000918 <stepperStopMove>:
 918:	e0 e2       	ldi	r30, 0x20	; 32
 91a:	fb e0       	ldi	r31, 0x0B	; 11
 91c:	80 81       	ld	r24, Z
 91e:	8e 7f       	andi	r24, 0xFE	; 254
 920:	80 83       	st	Z, r24
 922:	08 95       	ret

00000924 <stepperIncrementPosition>:
 924:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 928:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 92c:	20 81       	ld	r18, Z
 92e:	31 81       	ldd	r19, Z+1	; 0x01
 930:	22 83       	std	Z+2, r18	; 0x02
 932:	33 83       	std	Z+3, r19	; 0x03
 934:	28 0f       	add	r18, r24
 936:	31 1d       	adc	r19, r1
 938:	87 fd       	sbrc	r24, 7
 93a:	3a 95       	dec	r19
 93c:	20 83       	st	Z, r18
 93e:	31 83       	std	Z+1, r19	; 0x01
 940:	08 95       	ret

00000942 <stepperSetDecay>:
 942:	e0 e6       	ldi	r30, 0x60	; 96
 944:	f4 e0       	ldi	r31, 0x04	; 4
 946:	90 81       	ld	r25, Z
 948:	90 68       	ori	r25, 0x80	; 128
 94a:	90 83       	st	Z, r25
 94c:	17 8a       	std	Z+23, r1	; 0x17
 94e:	81 30       	cpi	r24, 0x01	; 1
 950:	19 f0       	breq	.+6      	; 0x958 <stepperSetDecay+0x16>
 952:	82 30       	cpi	r24, 0x02	; 2
 954:	39 f0       	breq	.+14     	; 0x964 <stepperSetDecay+0x22>
 956:	0c c0       	rjmp	.+24     	; 0x970 <stepperSetDecay+0x2e>
 958:	e0 e6       	ldi	r30, 0x60	; 96
 95a:	f4 e0       	ldi	r31, 0x04	; 4
 95c:	94 81       	ldd	r25, Z+4	; 0x04
 95e:	90 68       	ori	r25, 0x80	; 128
 960:	94 83       	std	Z+4, r25	; 0x04
 962:	0e c0       	rjmp	.+28     	; 0x980 <stepperSetDecay+0x3e>
 964:	e0 e6       	ldi	r30, 0x60	; 96
 966:	f4 e0       	ldi	r31, 0x04	; 4
 968:	94 81       	ldd	r25, Z+4	; 0x04
 96a:	9f 77       	andi	r25, 0x7F	; 127
 96c:	94 83       	std	Z+4, r25	; 0x04
 96e:	08 c0       	rjmp	.+16     	; 0x980 <stepperSetDecay+0x3e>
 970:	e0 e6       	ldi	r30, 0x60	; 96
 972:	f4 e0       	ldi	r31, 0x04	; 4
 974:	80 81       	ld	r24, Z
 976:	8f 77       	andi	r24, 0x7F	; 127
 978:	80 83       	st	Z, r24
 97a:	84 e0       	ldi	r24, 0x04	; 4
 97c:	87 8b       	std	Z+23, r24	; 0x17
 97e:	80 e0       	ldi	r24, 0x00	; 0
 980:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 984:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 988:	81 87       	std	Z+9, r24	; 0x09
 98a:	08 95       	ret

0000098c <stepperSetDirection>:
 98c:	81 30       	cpi	r24, 0x01	; 1
 98e:	31 f4       	brne	.+12     	; 0x99c <stepperSetDirection+0x10>
 990:	e0 e4       	ldi	r30, 0x40	; 64
 992:	f4 e0       	ldi	r31, 0x04	; 4
 994:	84 81       	ldd	r24, Z+4	; 0x04
 996:	82 60       	ori	r24, 0x02	; 2
 998:	84 83       	std	Z+4, r24	; 0x04
 99a:	08 95       	ret
 99c:	e0 e4       	ldi	r30, 0x40	; 64
 99e:	f4 e0       	ldi	r31, 0x04	; 4
 9a0:	84 81       	ldd	r24, Z+4	; 0x04
 9a2:	8d 7f       	andi	r24, 0xFD	; 253
 9a4:	84 83       	std	Z+4, r24	; 0x04
 9a6:	08 95       	ret

000009a8 <stepperSetCurrent>:
 9a8:	9c 01       	movw	r18, r24
 9aa:	21 50       	subi	r18, 0x01	; 1
 9ac:	31 09       	sbc	r19, r1
 9ae:	2e 3f       	cpi	r18, 0xFE	; 254
 9b0:	33 40       	sbci	r19, 0x03	; 3
 9b2:	38 f4       	brcc	.+14     	; 0x9c2 <stepperSetCurrent+0x1a>
 9b4:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 9b8:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 9bc:	87 83       	std	Z+7, r24	; 0x07
 9be:	90 87       	std	Z+8, r25	; 0x08
 9c0:	08 c0       	rjmp	.+16     	; 0x9d2 <stepperSetCurrent+0x2a>
 9c2:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 9c6:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 9ca:	83 e3       	ldi	r24, 0x33	; 51
 9cc:	91 e0       	ldi	r25, 0x01	; 1
 9ce:	87 83       	std	Z+7, r24	; 0x07
 9d0:	90 87       	std	Z+8, r25	; 0x08
 9d2:	e0 ea       	ldi	r30, 0xA0	; 160
 9d4:	f6 e0       	ldi	r31, 0x06	; 6
 9d6:	10 82       	st	Z, r1
 9d8:	a0 91 06 70 	lds	r26, 0x7006	; 0x807006 <pMotor>
 9dc:	b0 91 07 70 	lds	r27, 0x7007	; 0x807007 <pMotor+0x1>
 9e0:	17 96       	adiw	r26, 0x07	; 7
 9e2:	8d 91       	ld	r24, X+
 9e4:	9c 91       	ld	r25, X
 9e6:	18 97       	sbiw	r26, 0x08	; 8
 9e8:	00 24       	eor	r0, r0
 9ea:	96 95       	lsr	r25
 9ec:	87 95       	ror	r24
 9ee:	07 94       	ror	r0
 9f0:	96 95       	lsr	r25
 9f2:	87 95       	ror	r24
 9f4:	07 94       	ror	r0
 9f6:	98 2f       	mov	r25, r24
 9f8:	80 2d       	mov	r24, r0
 9fa:	1e 96       	adiw	r26, 0x0e	; 14
 9fc:	8d 93       	st	X+, r24
 9fe:	9c 93       	st	X, r25
 a00:	1f 97       	sbiw	r26, 0x0f	; 15
 a02:	82 83       	std	Z+2, r24	; 0x02
 a04:	1f 96       	adiw	r26, 0x0f	; 15
 a06:	8c 91       	ld	r24, X
 a08:	83 83       	std	Z+3, r24	; 0x03
 a0a:	81 e4       	ldi	r24, 0x41	; 65
 a0c:	80 83       	st	Z, r24
 a0e:	08 95       	ret

00000a10 <stepperSetSetPoint>:
 a10:	6a e0       	ldi	r22, 0x0A	; 10
 a12:	70 e0       	ldi	r23, 0x00	; 0
 a14:	0e 94 bd 06 	call	0xd7a	; 0xd7a <__divmodhi4>
 a18:	cb 01       	movw	r24, r22
 a1a:	88 0f       	add	r24, r24
 a1c:	99 1f       	adc	r25, r25
 a1e:	66 0f       	add	r22, r22
 a20:	77 1f       	adc	r23, r23
 a22:	66 0f       	add	r22, r22
 a24:	77 1f       	adc	r23, r23
 a26:	66 0f       	add	r22, r22
 a28:	77 1f       	adc	r23, r23
 a2a:	68 0f       	add	r22, r24
 a2c:	79 1f       	adc	r23, r25
 a2e:	6d 32       	cpi	r22, 0x2D	; 45
 a30:	81 e0       	ldi	r24, 0x01	; 1
 a32:	78 07       	cpc	r23, r24
 a34:	30 f4       	brcc	.+12     	; 0xa42 <stepperSetSetPoint+0x32>
 a36:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 a3a:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 a3e:	64 83       	std	Z+4, r22	; 0x04
 a40:	75 83       	std	Z+5, r23	; 0x05
 a42:	08 95       	ret

00000a44 <stepperSetPosition>:
 a44:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 a48:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 a4c:	20 81       	ld	r18, Z
 a4e:	31 81       	ldd	r19, Z+1	; 0x01
 a50:	22 83       	std	Z+2, r18	; 0x02
 a52:	33 83       	std	Z+3, r19	; 0x03
 a54:	6a e0       	ldi	r22, 0x0A	; 10
 a56:	70 e0       	ldi	r23, 0x00	; 0
 a58:	0e 94 bd 06 	call	0xd7a	; 0xd7a <__divmodhi4>
 a5c:	cb 01       	movw	r24, r22
 a5e:	88 0f       	add	r24, r24
 a60:	99 1f       	adc	r25, r25
 a62:	66 0f       	add	r22, r22
 a64:	77 1f       	adc	r23, r23
 a66:	66 0f       	add	r22, r22
 a68:	77 1f       	adc	r23, r23
 a6a:	66 0f       	add	r22, r22
 a6c:	77 1f       	adc	r23, r23
 a6e:	68 0f       	add	r22, r24
 a70:	79 1f       	adc	r23, r25
 a72:	6d 32       	cpi	r22, 0x2D	; 45
 a74:	81 e0       	ldi	r24, 0x01	; 1
 a76:	78 07       	cpc	r23, r24
 a78:	10 f4       	brcc	.+4      	; 0xa7e <stepperSetPosition+0x3a>
 a7a:	60 83       	st	Z, r22
 a7c:	71 83       	std	Z+1, r23	; 0x01
 a7e:	08 95       	ret

00000a80 <stepperAtSetPoint>:
 a80:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 a84:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 a88:	20 81       	ld	r18, Z
 a8a:	31 81       	ldd	r19, Z+1	; 0x01
 a8c:	84 81       	ldd	r24, Z+4	; 0x04
 a8e:	95 81       	ldd	r25, Z+5	; 0x05
 a90:	28 17       	cp	r18, r24
 a92:	39 07       	cpc	r19, r25
 a94:	11 f4       	brne	.+4      	; 0xa9a <stepperAtSetPoint+0x1a>
 a96:	81 e0       	ldi	r24, 0x01	; 1
 a98:	08 95       	ret
 a9a:	80 e0       	ldi	r24, 0x00	; 0
 a9c:	08 95       	ret

00000a9e <stepperPosition>:
 a9e:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 aa2:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 aa6:	80 81       	ld	r24, Z
 aa8:	91 81       	ldd	r25, Z+1	; 0x01
 aaa:	08 95       	ret

00000aac <stepperSetPoint>:
 aac:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 ab0:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 ab4:	84 81       	ldd	r24, Z+4	; 0x04
 ab6:	95 81       	ldd	r25, Z+5	; 0x05
 ab8:	08 95       	ret

00000aba <stepperSpeed>:
 aba:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 abe:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 ac2:	82 85       	ldd	r24, Z+10	; 0x0a
 ac4:	93 85       	ldd	r25, Z+11	; 0x0b
 ac6:	08 95       	ret

00000ac8 <stepperConfigTimeoutTimer>:
 ac8:	bc 01       	movw	r22, r24
 aca:	80 91 04 70 	lds	r24, 0x7004	; 0x807004 <stepperTimeoutTimer>
 ace:	90 91 05 70 	lds	r25, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 ad2:	0e 94 8b 06 	call	0xd16	; 0xd16 <systemConfigTCB>
 ad6:	08 95       	ret

00000ad8 <stepperInit>:
 ad8:	e0 e4       	ldi	r30, 0x40	; 64
 ada:	f4 e0       	ldi	r31, 0x04	; 4
 adc:	84 81       	ldd	r24, Z+4	; 0x04
 ade:	84 60       	ori	r24, 0x04	; 4
 ae0:	84 83       	std	Z+4, r24	; 0x04
 ae2:	8a e9       	ldi	r24, 0x9A	; 154
 ae4:	91 e0       	ldi	r25, 0x01	; 1
 ae6:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <stepperSetCurrent>
 aea:	81 e0       	ldi	r24, 0x01	; 1
 aec:	0e 94 73 04 	call	0x8e6	; 0x8e6 <stepperSetStepMode>
 af0:	84 e6       	ldi	r24, 0x64	; 100
 af2:	90 e0       	ldi	r25, 0x00	; 0
 af4:	0e 94 85 04 	call	0x90a	; 0x90a <stepperSetSpeed>
 af8:	80 e0       	ldi	r24, 0x00	; 0
 afa:	0e 94 a1 04 	call	0x942	; 0x942 <stepperSetDecay>
 afe:	8d e8       	ldi	r24, 0x8D	; 141
 b00:	9b e5       	ldi	r25, 0x5B	; 91
 b02:	0e 94 64 05 	call	0xac8	; 0xac8 <stepperConfigTimeoutTimer>
 b06:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b0a:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b0e:	8f ef       	ldi	r24, 0xFF	; 255
 b10:	9f ef       	ldi	r25, 0xFF	; 255
 b12:	80 83       	st	Z, r24
 b14:	91 83       	std	Z+1, r25	; 0x01
 b16:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b1a:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b1e:	84 83       	std	Z+4, r24	; 0x04
 b20:	95 83       	std	Z+5, r25	; 0x05
 b22:	82 83       	std	Z+2, r24	; 0x02
 b24:	93 83       	std	Z+3, r25	; 0x03
 b26:	08 95       	ret

00000b28 <stepperStartTimeoutTimer>:
 b28:	80 91 04 70 	lds	r24, 0x7004	; 0x807004 <stepperTimeoutTimer>
 b2c:	90 91 05 70 	lds	r25, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 b30:	0e 94 9f 06 	call	0xd3e	; 0xd3e <systemEnableTCB>
 b34:	08 95       	ret

00000b36 <stepperClearTimeoutAmount>:
 b36:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b3a:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b3e:	14 86       	std	Z+12, r1	; 0x0c
 b40:	08 95       	ret

00000b42 <stepperIncrementTimeoutAmount>:
 b42:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b46:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b4a:	84 85       	ldd	r24, Z+12	; 0x0c
 b4c:	8f 5f       	subi	r24, 0xFF	; 255
 b4e:	84 87       	std	Z+12, r24	; 0x0c
 b50:	08 95       	ret

00000b52 <stepperSetFlag>:
 b52:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b56:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b5a:	95 85       	ldd	r25, Z+13	; 0x0d
 b5c:	89 2b       	or	r24, r25
 b5e:	85 87       	std	Z+13, r24	; 0x0d
 b60:	08 95       	ret

00000b62 <stepperClearFlag>:
 b62:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b66:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b6a:	80 95       	com	r24
 b6c:	95 85       	ldd	r25, Z+13	; 0x0d
 b6e:	89 23       	and	r24, r25
 b70:	85 87       	std	Z+13, r24	; 0x0d
 b72:	08 95       	ret

00000b74 <stepperFlags>:
 b74:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b78:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b7c:	85 85       	ldd	r24, Z+13	; 0x0d
 b7e:	08 95       	ret

00000b80 <stepperCurrentLimit>:
 b80:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b84:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b88:	87 81       	ldd	r24, Z+7	; 0x07
 b8a:	90 85       	ldd	r25, Z+8	; 0x08
 b8c:	08 95       	ret

00000b8e <stepperStepMode>:
 b8e:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b92:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 b96:	86 81       	ldd	r24, Z+6	; 0x06
 b98:	08 95       	ret

00000b9a <stepperTimeoutAmount>:
 b9a:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 b9e:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 ba2:	84 85       	ldd	r24, Z+12	; 0x0c
 ba4:	08 95       	ret

00000ba6 <stepperTimeoutCnt>:
Returns: the CNT register of the stepper timeout timer.
Description: see returns.
*/
uint16_t stepperTimeoutCnt()
{
	return stepperTimeoutTimer->CNT;
 ba6:	e0 91 04 70 	lds	r30, 0x7004	; 0x807004 <stepperTimeoutTimer>
 baa:	f0 91 05 70 	lds	r31, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 bae:	82 85       	ldd	r24, Z+10	; 0x0a
 bb0:	93 85       	ldd	r25, Z+11	; 0x0b
}
 bb2:	08 95       	ret

00000bb4 <stepperClearTimeoutCnt>:
Returns: none
Description: sets the CNT register of the stepper timeout timer to zero.
*/
void stepperClearTimeoutCnt()
{
	stepperTimeoutTimer->CNT = 0;
 bb4:	e0 91 04 70 	lds	r30, 0x7004	; 0x807004 <stepperTimeoutTimer>
 bb8:	f0 91 05 70 	lds	r31, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 bbc:	12 86       	std	Z+10, r1	; 0x0a
 bbe:	13 86       	std	Z+11, r1	; 0x0b
 bc0:	08 95       	ret

00000bc2 <stepperStopTimeoutTimer>:
Returns: none
Description: Disables the timer. Clear timer CNT and timeoutAmount.
*/
void stepperStopTimeoutTimer()
{
	systemDisableTCB(stepperTimeoutTimer);
 bc2:	80 91 04 70 	lds	r24, 0x7004	; 0x807004 <stepperTimeoutTimer>
 bc6:	90 91 05 70 	lds	r25, 0x7005	; 0x807005 <stepperTimeoutTimer+0x1>
 bca:	0e 94 a4 06 	call	0xd48	; 0xd48 <systemDisableTCB>
	stepperClearTimeoutAmount();
 bce:	0e 94 9b 05 	call	0xb36	; 0xb36 <stepperClearTimeoutAmount>
	stepperClearTimeoutCnt();
 bd2:	0e 94 da 05 	call	0xbb4	; 0xbb4 <stepperClearTimeoutCnt>
 bd6:	08 95       	ret

00000bd8 <stepperGoToZero>:
			This means the motor can't turn any further and is at position 0.
			Then resets the position and set point to 0.
*/
void stepperGoToZero()
{
	stepperSetDirection(DIRECTION_CCW);								//Set direction to count down towards soft
 bd8:	81 e0       	ldi	r24, 0x01	; 1
 bda:	0e 94 c6 04 	call	0x98c	; 0x98c <stepperSetDirection>
	stepperStartMove();												//Start the stepper PWM signal
 bde:	0e 94 b4 03 	call	0x768	; 0x768 <stepperStartMove>
	STEPPER_ENABLE;													//Enable the driver.
 be2:	e0 e4       	ldi	r30, 0x40	; 64
 be4:	f4 e0       	ldi	r31, 0x04	; 4
 be6:	84 81       	ldd	r24, Z+4	; 0x04
 be8:	8b 7f       	andi	r24, 0xFB	; 251
 bea:	84 83       	std	Z+4, r24	; 0x04
	
	stepperConfigTimeoutTimer(TCB_FREQ_15HZ);						//Set the period of the timeout timer.
 bec:	8a e1       	ldi	r24, 0x1A	; 26
 bee:	96 e0       	ldi	r25, 0x06	; 6
 bf0:	0e 94 64 05 	call	0xac8	; 0xac8 <stepperConfigTimeoutTimer>
	stepperClearTimeoutAmount();									//Clear the timer count if there is one.
 bf4:	0e 94 9b 05 	call	0xb36	; 0xb36 <stepperClearTimeoutAmount>
	stepperStartTimeoutTimer();										//Start counter.
 bf8:	0e 94 94 05 	call	0xb28	; 0xb28 <stepperStartTimeoutTimer>
	
	/*Wait for the timeout flag to be set or for the previous position to be
	greater than the current position. If the motor stops where the encoder
	is on an edge it will keep firing the encoder interrupt and resetting the
	timeoutCounter.*/
	while (pMotor->timeoutAmount < 15) {}							
 bfc:	e0 91 06 70 	lds	r30, 0x7006	; 0x807006 <pMotor>
 c00:	f0 91 07 70 	lds	r31, 0x7007	; 0x807007 <pMotor+0x1>
 c04:	84 85       	ldd	r24, Z+12	; 0x0c
 c06:	8f 30       	cpi	r24, 0x0F	; 15
 c08:	c8 f3       	brcs	.-14     	; 0xbfc <stepperGoToZero+0x24>
	
	stepperStopTimeoutTimer();										//Stop the timer.
 c0a:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <stepperStopTimeoutTimer>
	stepperStopMove();												//Stop the motor.
 c0e:	0e 94 8c 04 	call	0x918	; 0x918 <stepperStopMove>
	
	stepperSetSetPoint(0);											//Change the current set point.
 c12:	80 e0       	ldi	r24, 0x00	; 0
 c14:	90 e0       	ldi	r25, 0x00	; 0
 c16:	0e 94 08 05 	call	0xa10	; 0xa10 <stepperSetSetPoint>
	stepperSetPosition(0);											//Change the current position.
 c1a:	80 e0       	ldi	r24, 0x00	; 0
 c1c:	90 e0       	ldi	r25, 0x00	; 0
 c1e:	0e 94 22 05 	call	0xa44	; 0xa44 <stepperSetPosition>
	stepperClearFlag(FLAG_GO_TO_ZERO_bm);							//Clear the flag.
 c22:	88 e0       	ldi	r24, 0x08	; 8
 c24:	0e 94 b1 05 	call	0xb62	; 0xb62 <stepperClearFlag>
 c28:	08 95       	ret

00000c2a <stepperIsMoving>:
Returns: true if the stepper step timer is running signifying that the motor is turning.
Description: see returns.
*/
bool stepperIsMoving()
{
	return TCB2.STATUS;
 c2a:	90 91 27 0b 	lds	r25, 0x0B27	; 0x800b27 <__RODATA_PM_OFFSET__+0x7f8b27>
 c2e:	81 e0       	ldi	r24, 0x01	; 1
 c30:	91 11       	cpse	r25, r1
 c32:	01 c0       	rjmp	.+2      	; 0xc36 <stepperIsMoving+0xc>
 c34:	80 e0       	ldi	r24, 0x00	; 0
 c36:	08 95       	ret

00000c38 <systemPortAConfig>:
Description: Configures all the pins in port A.
*/
void systemPortAConfig()
{
	
	PORTA.DIR |= LED1_PIN								//LED Pins as outputs.
 c38:	e0 e0       	ldi	r30, 0x00	; 0
 c3a:	f4 e0       	ldi	r31, 0x04	; 4
 c3c:	80 81       	ld	r24, Z
 c3e:	8c 69       	ori	r24, 0x9C	; 156
 c40:	80 83       	st	Z, r24
				| LED2_PIN
				| LED3_PIN
				| CLK_OUT_PIN;							//CLKOUT pin as output.
				
	LED1_OFF;											//Start with all LEDs off.
 c42:	84 81       	ldd	r24, Z+4	; 0x04
 c44:	8b 7f       	andi	r24, 0xFB	; 251
 c46:	84 83       	std	Z+4, r24	; 0x04
	LED2_OFF;
 c48:	84 81       	ldd	r24, Z+4	; 0x04
 c4a:	87 7f       	andi	r24, 0xF7	; 247
 c4c:	84 83       	std	Z+4, r24	; 0x04
	LED3_OFF;
 c4e:	84 81       	ldd	r24, Z+4	; 0x04
 c50:	8f 7e       	andi	r24, 0xEF	; 239
 c52:	84 83       	std	Z+4, r24	; 0x04
	
	PORTA.DIR &= ~(ENC_A_PIN							//Encoder pins as input.	
 c54:	80 81       	ld	r24, Z
 c56:	8c 7f       	andi	r24, 0xFC	; 252
 c58:	80 83       	st	Z, r24
				| ENC_B_PIN);
				
	PORTA.PIN0CTRL = PORT_ISC_BOTHEDGES_gc;				//Encoder A pin interrupt enabled.
 c5a:	81 e0       	ldi	r24, 0x01	; 1
 c5c:	80 8b       	std	Z+16, r24	; 0x10
	
	CCP = CCP_IOREG_gc;
 c5e:	88 ed       	ldi	r24, 0xD8	; 216
 c60:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLA = CLKCTRL_CLKOUT_bm;				//Clock out on PA7 (CLK_OUT_PIN)
 c62:	80 e8       	ldi	r24, 0x80	; 128
 c64:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__RODATA_PM_OFFSET__+0x7f8060>
 c68:	08 95       	ret

00000c6a <systemPortCConfig>:
Returns: none
Description: Configures all the pins in port C.
*/
void systemPortCConfig()
{
	PORTC.DIR |= DIR_PIN								//Direction, step, enable, and home pin all outputs.
 c6a:	e0 e4       	ldi	r30, 0x40	; 64
 c6c:	f4 e0       	ldi	r31, 0x04	; 4
 c6e:	80 81       	ld	r24, Z
 c70:	87 60       	ori	r24, 0x07	; 7
 c72:	80 83       	st	Z, r24
				| STEP_PIN
				| nENBL_PIN;
				
	PORTC.OUT &= ~(nENBL_PIN);							//Enable pin low enables the DRV8825.
 c74:	84 81       	ldd	r24, Z+4	; 0x04
 c76:	8b 7f       	andi	r24, 0xFB	; 251
 c78:	84 83       	std	Z+4, r24	; 0x04
				
	PORTC.DIR &= ~nHOME_PIN;							//Home as input.
 c7a:	80 81       	ld	r24, Z
 c7c:	87 7f       	andi	r24, 0xF7	; 247
 c7e:	80 83       	st	Z, r24
	
	TCB2.CTRLB = TCB_CCMPEN_bm							//Waveform will override step pin output.
 c80:	e0 e2       	ldi	r30, 0x20	; 32
 c82:	fb e0       	ldi	r31, 0x0B	; 11
 c84:	87 e1       	ldi	r24, 0x17	; 23
 c86:	81 83       	std	Z+1, r24	; 0x01
				|TCB_CNTMODE_PWM8_gc;					//TCB2 set to 8-bit PWM mode.
	TCB2.CTRLA = TCB_CLKSEL_TCA0_gc;					//TCB2 uses TCA0 as clock source.
 c88:	84 e0       	ldi	r24, 0x04	; 4
 c8a:	80 83       	st	Z, r24
 c8c:	08 95       	ret

00000c8e <systemPortDConfig>:
Returns: none
Description: Configures all the pins in port D.
*/
void systemPortDConfig()
{
	PORTD.DIR |= MODE0_PIN								//Mode pins, reset, sleep, and decay as outputs.
 c8e:	e0 e6       	ldi	r30, 0x60	; 96
 c90:	f4 e0       	ldi	r31, 0x04	; 4
 c92:	80 81       	ld	r24, Z
 c94:	8f 69       	ori	r24, 0x9F	; 159
 c96:	80 83       	st	Z, r24
				| MODE2_PIN
				| nRESET_PIN
				| nSLEEP_PIN
				| DECAY_PIN;
				
	PORTD.OUT |= (nSLEEP_PIN | nRESET_PIN);				//Sleep and reset needed high for DRV8825 operation.
 c98:	84 81       	ldd	r24, Z+4	; 0x04
 c9a:	88 61       	ori	r24, 0x18	; 24
 c9c:	84 83       	std	Z+4, r24	; 0x04
				
	PORTD.DIR &= ~nFAULT_PIN;							//Fault as input.
 c9e:	80 81       	ld	r24, Z
 ca0:	8f 7d       	andi	r24, 0xDF	; 223
 ca2:	80 83       	st	Z, r24
	
	VREF.DAC0REF = VREF_ALWAYSON_bm						//DAC reference voltage always on for VREF_PIN.
 ca4:	83 e8       	ldi	r24, 0x83	; 131
 ca6:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__RODATA_PM_OFFSET__+0x7f80a2>
 caa:	08 95       	ret

00000cac <systemPortFConfig>:
Returns: none
Description: Configures all the pins in port F.
*/
void systemPortFConfig()
{
	PORTF.DIR &= ~(AIN_12V_PIN | AIN_3V3_PIN);			//Analog pins as inputs
 cac:	e0 ea       	ldi	r30, 0xA0	; 160
 cae:	f4 e0       	ldi	r31, 0x04	; 4
 cb0:	80 81       	ld	r24, Z
 cb2:	8f 7c       	andi	r24, 0xCF	; 207
 cb4:	80 83       	st	Z, r24
	iicInit();
 cb6:	0e 94 8f 00 	call	0x11e	; 0x11e <iicInit>
 cba:	08 95       	ret

00000cbc <systemClockConfig>:
Returns: none
Description: Selects the 24MHz clock with no prescaler for the main/master clock.
*/
void systemClockConfig()
{
	CCP = CCP_IOREG_gc;
 cbc:	88 ed       	ldi	r24, 0xD8	; 216
 cbe:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.OSCHFCTRLA = CLKCTRL_FREQSEL_24M_gc			//24MHz frequency.
 cc0:	e0 e6       	ldi	r30, 0x60	; 96
 cc2:	f0 e0       	ldi	r31, 0x00	; 0
 cc4:	95 e2       	ldi	r25, 0x25	; 37
 cc6:	90 87       	std	Z+8, r25	; 0x08
					| CLKCTRL_AUTOTUNE_bm;				//Enable autotune.
					
	CCP = CCP_IOREG_gc;					
 cc8:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLB = 0;						 		//No prescaler, 24MHz clock.
 cca:	11 82       	std	Z+1, r1	; 0x01
 ccc:	08 95       	ret

00000cce <systemConfigADC>:
Returns: none
Description: Configure the ADC to sample the supply voltage.
*/
void systemConfigADC()
{
	VREF.ADC0REF |= VREF_REFSEL_2V500_gc;				//ADC0 reference as 2.5V;	
 cce:	e0 ea       	ldi	r30, 0xA0	; 160
 cd0:	f0 e0       	ldi	r31, 0x00	; 0
 cd2:	80 81       	ld	r24, Z
 cd4:	83 60       	ori	r24, 0x03	; 3
 cd6:	80 83       	st	Z, r24
	ADC0.CTRLA |= ADC_RESSEL_12BIT_gc					//12 bit conversions.
 cd8:	e0 e0       	ldi	r30, 0x00	; 0
 cda:	f6 e0       	ldi	r31, 0x06	; 6
 cdc:	80 81       	ld	r24, Z
 cde:	82 60       	ori	r24, 0x02	; 2
 ce0:	80 83       	st	Z, r24
				| ADC_FREERUN_bm;						//Enable freerunning mode.
	ADC0.CTRLC |= ADC_PRESC_DIV256_gc;					//ADC clock equals system clock div 2.
 ce2:	82 81       	ldd	r24, Z+2	; 0x02
 ce4:	8d 60       	ori	r24, 0x0D	; 13
 ce6:	82 83       	std	Z+2, r24	; 0x02
	ADC0.SAMPCTRL = 20;									//Set sample length to 20 ADC cycles.
 ce8:	84 e1       	ldi	r24, 0x14	; 20
 cea:	85 83       	std	Z+5, r24	; 0x05
	ADC0.CTRLE = ADC_WINCM_BELOW_gc;					//Compare mode set to below.
 cec:	81 e0       	ldi	r24, 0x01	; 1
 cee:	84 83       	std	Z+4, r24	; 0x04
	ADC0.MUXPOS = ADC_MUXPOS_AIN21_gc;					//Battery voltage divider is on PF5 which is AIN21.
 cf0:	95 e1       	ldi	r25, 0x15	; 21
 cf2:	90 87       	std	Z+8, r25	; 0x08
	ADC0.MUXNEG = ADC_MUXNEG_GND_gc;					//Negative input to ground.
 cf4:	90 e4       	ldi	r25, 0x40	; 64
 cf6:	91 87       	std	Z+9, r25	; 0x09
	//ADC0.INTCTRL = ADC_WCMP_bm;						//Enable window comparator interrupt.
	ADC0.WINLT = ADC_LOW_VOLTAGE;						//Low threshold is 11V.
 cf8:	24 e5       	ldi	r18, 0x54	; 84
 cfa:	39 e0       	ldi	r19, 0x09	; 9
 cfc:	22 8b       	std	Z+18, r18	; 0x12
 cfe:	33 8b       	std	Z+19, r19	; 0x13
	ADC0.DBGCTRL = ADC_DBGRUN_bm;						//Run while debuggin.
 d00:	86 87       	std	Z+14, r24	; 0x0e
	ADC0.CTRLA |= ADC_ENABLE_bm;						//Enable ADC.
 d02:	90 81       	ld	r25, Z
 d04:	91 60       	ori	r25, 0x01	; 1
 d06:	90 83       	st	Z, r25
	ADC0.COMMAND = ADC_STCONV_bm;						//Start converting.
 d08:	82 87       	std	Z+10, r24	; 0x0a
 d0a:	08 95       	ret

00000d0c <systemADCResult>:
Returns: The most recent value in the ADC0.RES register.
Description: read returns.
*/
uint16_t systemADCResult()
{
	return ADC0.RES;
 d0c:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <__RODATA_PM_OFFSET__+0x7f8610>
 d10:	90 91 11 06 	lds	r25, 0x0611	; 0x800611 <__RODATA_PM_OFFSET__+0x7f8611>
}
 d14:	08 95       	ret

00000d16 <systemConfigTCB>:
Returns: none
Description: Sets up a TCB in periodic interrupt mode to a set interval, cmp.
*/

void systemConfigTCB(TCB_t *tcb, uint16_t cmp)
{
 d16:	fc 01       	movw	r30, r24
	tcb->CTRLA = TCB_CLKSEL_TCA0_gc;					//Select TCA0 as clock source.
 d18:	84 e0       	ldi	r24, 0x04	; 4
 d1a:	80 83       	st	Z, r24
	tcb->CTRLB = TCB_CNTMODE_INT_gc;					//Periodic interrupt mode.
 d1c:	11 82       	std	Z+1, r1	; 0x01
	tcb->INTCTRL = TCB_CAPT_bm;							//Enable capture interrupt.
 d1e:	81 e0       	ldi	r24, 0x01	; 1
 d20:	85 83       	std	Z+5, r24	; 0x05
	tcb->CCMP = cmp;									//Set compare value.
 d22:	64 87       	std	Z+12, r22	; 0x0c
 d24:	75 87       	std	Z+13, r23	; 0x0d
 d26:	08 95       	ret

00000d28 <systemEnableTCA0>:
*/

void systemEnableTCA0()
{
	/*TCA frequency = 23437 Hz = 24,000,000 Hz / 1,024*/
	TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1024_gc			//Will be using TCA0 as source for TCB0
 d28:	e0 e0       	ldi	r30, 0x00	; 0
 d2a:	fa e0       	ldi	r31, 0x0A	; 10
 d2c:	8f e0       	ldi	r24, 0x0F	; 15
 d2e:	80 83       	st	Z, r24
					| TCA_SINGLE_ENABLE_bm;						//Enable TCA0.
	TCA0.SINGLE.DBGCTRL = 1;									//Run while debug.
 d30:	81 e0       	ldi	r24, 0x01	; 1
 d32:	86 87       	std	Z+14, r24	; 0x0e
	TCA0.SINGLE.PER = 0xFFFF;									//Max value for period.
 d34:	8f ef       	ldi	r24, 0xFF	; 255
 d36:	9f ef       	ldi	r25, 0xFF	; 255
 d38:	86 a3       	std	Z+38, r24	; 0x26
 d3a:	97 a3       	std	Z+39, r25	; 0x27
 d3c:	08 95       	ret

00000d3e <systemEnableTCB>:
Returns: none
Description: enables a TCB timer.
*/

void systemEnableTCB(TCB_t *tcb)
{
 d3e:	fc 01       	movw	r30, r24
	tcb->CTRLA |= TCB_ENABLE_bm;
 d40:	90 81       	ld	r25, Z
 d42:	91 60       	ori	r25, 0x01	; 1
 d44:	90 83       	st	Z, r25
 d46:	08 95       	ret

00000d48 <systemDisableTCB>:
Returns: none
Description: Disables a TCB timer.
*/

void systemDisableTCB(TCB_t *tcb)
{
 d48:	fc 01       	movw	r30, r24
	tcb->CTRLA &= ~(TCB_ENABLE_bm);
 d4a:	90 81       	ld	r25, Z
 d4c:	9e 7f       	andi	r25, 0xFE	; 254
 d4e:	90 83       	st	Z, r25
 d50:	08 95       	ret

00000d52 <__udivmodhi4>:
 d52:	aa 1b       	sub	r26, r26
 d54:	bb 1b       	sub	r27, r27
 d56:	51 e1       	ldi	r21, 0x11	; 17
 d58:	07 c0       	rjmp	.+14     	; 0xd68 <__udivmodhi4_ep>

00000d5a <__udivmodhi4_loop>:
 d5a:	aa 1f       	adc	r26, r26
 d5c:	bb 1f       	adc	r27, r27
 d5e:	a6 17       	cp	r26, r22
 d60:	b7 07       	cpc	r27, r23
 d62:	10 f0       	brcs	.+4      	; 0xd68 <__udivmodhi4_ep>
 d64:	a6 1b       	sub	r26, r22
 d66:	b7 0b       	sbc	r27, r23

00000d68 <__udivmodhi4_ep>:
 d68:	88 1f       	adc	r24, r24
 d6a:	99 1f       	adc	r25, r25
 d6c:	5a 95       	dec	r21
 d6e:	a9 f7       	brne	.-22     	; 0xd5a <__udivmodhi4_loop>
 d70:	80 95       	com	r24
 d72:	90 95       	com	r25
 d74:	bc 01       	movw	r22, r24
 d76:	cd 01       	movw	r24, r26
 d78:	08 95       	ret

00000d7a <__divmodhi4>:
 d7a:	97 fb       	bst	r25, 7
 d7c:	07 2e       	mov	r0, r23
 d7e:	16 f4       	brtc	.+4      	; 0xd84 <__divmodhi4+0xa>
 d80:	00 94       	com	r0
 d82:	07 d0       	rcall	.+14     	; 0xd92 <__divmodhi4_neg1>
 d84:	77 fd       	sbrc	r23, 7
 d86:	09 d0       	rcall	.+18     	; 0xd9a <__divmodhi4_neg2>
 d88:	0e 94 a9 06 	call	0xd52	; 0xd52 <__udivmodhi4>
 d8c:	07 fc       	sbrc	r0, 7
 d8e:	05 d0       	rcall	.+10     	; 0xd9a <__divmodhi4_neg2>
 d90:	3e f4       	brtc	.+14     	; 0xda0 <__divmodhi4_exit>

00000d92 <__divmodhi4_neg1>:
 d92:	90 95       	com	r25
 d94:	81 95       	neg	r24
 d96:	9f 4f       	sbci	r25, 0xFF	; 255
 d98:	08 95       	ret

00000d9a <__divmodhi4_neg2>:
 d9a:	70 95       	com	r23
 d9c:	61 95       	neg	r22
 d9e:	7f 4f       	sbci	r23, 0xFF	; 255

00000da0 <__divmodhi4_exit>:
 da0:	08 95       	ret

00000da2 <__tablejump2__>:
 da2:	ee 0f       	add	r30, r30
 da4:	ff 1f       	adc	r31, r31
 da6:	05 90       	lpm	r0, Z+
 da8:	f4 91       	lpm	r31, Z
 daa:	e0 2d       	mov	r30, r0
 dac:	09 94       	ijmp

00000dae <__umulhisi3>:
 dae:	a2 9f       	mul	r26, r18
 db0:	b0 01       	movw	r22, r0
 db2:	b3 9f       	mul	r27, r19
 db4:	c0 01       	movw	r24, r0
 db6:	a3 9f       	mul	r26, r19
 db8:	70 0d       	add	r23, r0
 dba:	81 1d       	adc	r24, r1
 dbc:	11 24       	eor	r1, r1
 dbe:	91 1d       	adc	r25, r1
 dc0:	b2 9f       	mul	r27, r18
 dc2:	70 0d       	add	r23, r0
 dc4:	81 1d       	adc	r24, r1
 dc6:	11 24       	eor	r1, r1
 dc8:	91 1d       	adc	r25, r1
 dca:	08 95       	ret

00000dcc <__cmpdi2_s8>:
 dcc:	00 24       	eor	r0, r0
 dce:	a7 fd       	sbrc	r26, 7
 dd0:	00 94       	com	r0
 dd2:	2a 17       	cp	r18, r26
 dd4:	30 05       	cpc	r19, r0
 dd6:	40 05       	cpc	r20, r0
 dd8:	50 05       	cpc	r21, r0
 dda:	60 05       	cpc	r22, r0
 ddc:	70 05       	cpc	r23, r0
 dde:	80 05       	cpc	r24, r0
 de0:	90 05       	cpc	r25, r0
 de2:	08 95       	ret

00000de4 <_exit>:
 de4:	f8 94       	cli

00000de6 <__stop_program>:
 de6:	ff cf       	rjmp	.-2      	; 0xde6 <__stop_program>
